/*!
 * Ayisha.js - Complete Modular Directive System
 * (c) 2023 devBen - Benito Massidda
 * License: MIT
 */
!function () { if ("undefined" != typeof window && window.AyishaVDOM) return; class e { constructor() { this.errors = [], this.listeners = [] } report(e, t = {}) { const i = { error: e, context: t, timestamp: Date.now() }; this.errors.push(i), this.listeners.forEach((e => { try { e(i) } catch { } })) } getAll() { return this.errors } clear() { this.errors = [] } onError(e) { this.listeners.push(e) } } class t { constructor(e, t, i) { this.vNode = e, this.ctx = t, this.ayisha = i, this.total = 0, this.completed = 0, this.thenQueue = [], this.finallyQueue = [], this.done = !1, this.syncCompleted = !1 } addTask(e) { this.total++, Promise.resolve("function" == typeof e ? e() : e).then((() => this._onComplete())).catch((() => this._onComplete())) } addAsyncTask() { return this.total++, () => this._onComplete() } addThen(e) { Array.isArray(e) ? e.forEach((e => this.thenQueue.push(e))) : "string" == typeof e ? e.split(/;;|\n/).map((e => e.trim())).filter(Boolean).forEach((e => this.thenQueue.push(e))) : this.thenQueue.push(e), this._preInitializeVariablesFromExpressions(e) } addFinally(e) { Array.isArray(e) ? e.forEach((e => this.finallyQueue.push(e))) : "string" == typeof e ? e.split(/;;|\n/).map((e => e.trim())).filter(Boolean).forEach((e => this.finallyQueue.push(e))) : this.finallyQueue.push(e), this._preInitializeVariablesFromExpressions(e) } _preInitializeVariablesFromExpressions(e) { if (!e || !this.ayisha?.evaluator) return; let t = []; t = Array.isArray(e) ? e.flat().filter(Boolean) : "string" == typeof e ? e.split(/;;|\n/).map((e => e.trim())).filter(Boolean) : [e], t.forEach((e => { if ("string" != typeof e) return; const t = /([a-zA-Z_$][a-zA-Z0-9_$]*(?:\.[a-zA-Z_$][a-zA-Z0-9_$]*)*)\s*=\s*[^=]/g; let i; for (; null !== (i = t.exec(e));) { const e = i[1].trim(); if (e.includes(".")) { const t = e.split(".")[0]; this._ensureVariableInState(t, "object"), this._ensureNestedPath(e) } else this._ensureVariableInState(e, "auto") } })) } _ensureVariableInState(e, t = "auto") { if (!e || !this.ayisha?.evaluator?.state) return; if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(e)) return; if (e in this.ayisha.evaluator.state) return; if (["JSON", "Object", "Array", "String", "Number", "Boolean", "Date", "Math", "RegExp", "console", "window", "document", "setTimeout", "setInterval", "fetch", "localStorage", "sessionStorage", "history", "location", "navigator", "undefined", "null", "true", "false"].includes(e)) return; let i; i = "object" === t ? {} : "array" === t || /items|list|array|data|results|errors|posts|todos|users|cats|dogs|products|content/.test(e) ? [] : /count|total|index|id|size|length|number|num|page|limit|offset/.test(e) ? 0 : !/show|hide|is|has|can|should|valid|enable|subscribed|loading|visible/.test(e) && (/user|config|form|settings|profile|metadata|info/.test(e) ? {} : void 0), this.ayisha.evaluator.state[e] = i } _ensureNestedPath(e) { e && this.ayisha?.evaluator?.state && w.setNested(this.ayisha.evaluator.state, e, void 0) } _onComplete() { this.done || (this.completed++, this.completed > this.total && (this.completed = this.total), this._checkCompletion()) } markSyncDone() { this.syncCompleted = !0, this._checkCompletion() } _checkCompletion() { this.done || this.completed >= this.total && this.syncCompleted && (this.done = !0, this._executeThenAndFinally()) } _executeThenAndFinally() { this.thenQueue.length > 0 ? setTimeout((() => { this.thenQueue.forEach((e => { try { "function" == typeof e ? e() : this.ctx && void 0 !== this.ctx._eventResult ? this.ayisha.evaluator.executeDirectiveExpression(e, this.ctx, this.ctx._eventResult, !0) : this.ayisha.evaluator.executeDirectiveExpression(e, this.ctx, null, !0) } catch (e) { } })), setTimeout((() => { this.finallyQueue.length > 0 && this.finallyQueue.forEach((e => { try { "function" == typeof e ? e() : this.ayisha.evaluator.executeDirectiveExpression(e, this.ctx, null, !0) } catch (e) { } })) }), 1500) }), 1500) : setTimeout((() => { this.finallyQueue.length > 0 && this.finallyQueue.forEach((e => { try { "function" == typeof e ? e() : this.ayisha.evaluator.executeDirectiveExpression(e, this.ctx, null, !0) } catch (e) { } })) }), 1500) } } class i { autoPageName(e) { return "string" == typeof e && e.trim() && !e.trim().startsWith("'") && !e.trim().startsWith('"') && /^[a-zA-Z0-9_]+$/.test(e.trim()) ? `'${e.trim()}'` : e } extractDependencies(e) { if ("string" != typeof e) return []; const t = e.match(/\b([a-zA-Z_$][a-zA-Z0-9_$]*)\b/g); if (!t) return []; const i = ["true", "false", "null", "undefined", "if", "else", "for", "while", "switch", "case", "default", "try", "catch", "finally", "return", "var", "let", "const", "function", "new", "typeof", "instanceof", "in", "do", "break", "continue", "this", "window", "document", "Math", "Date", "Array", "Object", "String", "Number", "Boolean", "RegExp", "JSON", "console", "setTimeout", "setInterval", "fetch", "localStorage", "sessionStorage", "history", "location", "navigator"]; return t.filter(((e, t, s) => s.indexOf(e) === t && !i.includes(e))) } constructor(e) { this.state = e } evalExpr(e, t = {}, i) { const s = e.trim(); if (/^['"].*['"]$/.test(s)) return s.slice(1, -1); if (/^\d+(\.\d+)?$/.test(s)) return Number(s); try { const s = new Proxy(this.state, { get: (e, t) => e[t], set: (e, t, i) => (e[t] = i, !0) }); return new Function("state", "ctx", "event", `with(state){with(ctx||{}){return (${e})}}`)(s, t, i) } catch { return } } executeMultipleExpressions(e, t = {}, i) { const s = e.trim(); if (!this.hasMultipleAssignments(s)) return !1; const r = this.parseMultipleExpressions(s); try { const e = new Proxy(this.state, { get: (e, t) => e[t], set: (e, t, i) => (e[t] = i, !0) }); for (const s of r) s.trim() && new Function("state", "ctx", "event", `with(state){with(ctx||{}){${s.trim()}}}`)(e, t, i); return !0 } catch (e) { return !1 } } executeDirectiveExpression(e, t = {}, i = null, s = !0) { let r = e; this.hasInterpolation(e) && (r = this.evalAttrValue(e, t)); const n = r.replace(/\bstate\./g, ""); try { if (this.executeMultipleExpressions(n, t, i)) return s && setTimeout((() => window.ayisha && window.ayisha.render()), 0), !0; return new Function("state", "ctx", "event", `with(state){with(ctx||{}){${n}}}`)(this.state, t || {}, i), s && setTimeout((() => window.ayisha && window.ayisha.render()), 0), !0 } catch (e) { return !1 } } hasMultipleAssignments(e) { if (e.includes("=>")) return !1; if (e.includes("(") && e.includes(")")) { return e.includes(";") } if (e.includes(";")) return !0; if (e.includes(",") && !e.includes("(")) return !0; return /\w+\s*=\s*[^=\s]+\s+\w+\s*=\s*/.test(e) } parseMultipleExpressions(e) { if (e.includes(";")) return e.split(";").map((e => e.trim())).filter((e => e)); if (e.includes(",") && !e.includes("(")) return e.split(",").map((e => e.trim())).filter((e => e)); const t = []; let i = "", s = !1, r = "", n = 0, a = 0; for (; a < e.length;) { const o = e[a]; if (s || '"' !== o && "'" !== o) if (s && o === r && "\\" !== e[a - 1]) s = !1, r = "", i += o; else if (s || "(" !== o) if (s || ")" !== o) if (s || " " !== o || 0 !== n) i += o; else { e.substring(a + 1).trim().match(/^\w+\s*=/) && i.trim().includes("=") ? (t.push(i.trim()), i = "") : i += o } else n--, i += o; else n++, i += o; else s = !0, r = o, i += o; a++ } return i.trim() && t.push(i.trim()), t.length > 1 ? t : [e] } evalText(e, t) { return e.replace(/{{(.*?)}}/g, ((e, i) => { const s = this.evalExpr(i.trim(), t); return null != s ? s : "" })) } evalAttrValue(e, t) { let i = e.replace(/{{(.*?)}}/g, ((e, i) => { const s = this.evalExpr(i.trim(), t); return null != s ? s : "" })); if (i = i.replace(/\[\{(.*?)\}\]/g, ((e, i) => { const s = this.evalExpr(i.trim(), t); return null != s ? s : "" })), /^\{([^{}]+)\}$/.test(i.trim())) { const e = i.trim().slice(1, -1), s = this.evalExpr(e, t); return null != s ? s : "" } return i = i.replace(/\{([^{}]+)\}/g, ((e, i) => { if (/^\{\{.*\}\}$/.test(e)) return e; const s = this.evalExpr(i.trim(), t); return null != s ? s : "" })), i } autoVarExpr(e) { return "string" == typeof e && /^\w+$/.test(e.trim()) ? `{${e.trim()}}` : e } hasInterpolation(e) { return /\{\{.*?\}\}|\{[\w$.]+\}/.test(e) } ensureVarInState(e, t = !1, i = null) { if ("string" != typeof e) return; if (e.includes("=") || e.includes("<") || e.includes(">") || e.includes("!") || e.includes("&") || e.includes("|") || e.includes("'") || e.includes('"') || e.includes("(") || e.includes(")") || e.includes(" ") || e.includes("+") || e.includes("-") || e.includes("*") || e.includes("/") || e.includes("%") || e.includes("[") || e.includes("]") || e.includes("{") || e.includes("}") || e.includes("?") || e.includes(":") || e.includes(";") || e.includes(",")) return; const s = ["JSON", "Object", "Array", "String", "Number", "Boolean", "Date", "Math", "RegExp", "console", "window", "document", "setTimeout", "setInterval", "fetch", "localStorage", "sessionStorage", "history", "location", "navigator", "undefined", "null", "true", "false"], r = e.match(/([\w$]+)\.(push|pop|shift|unshift|filter|map|reduce|forEach|length|slice|splice)/); if (r) { const e = r[1]; return void (s.includes(e) || e in this.state || (this.state[e] = [])) } const n = e.split(".")[0]; if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n)) return; s.includes(n) || n in this.state || ("number" === i ? this.state[n] = 0 : "checkbox" === i ? this.state[n] = !1 : t ? this.state[n] = void 0 : /items|list|array|data|results|errors|posts|todos|users/.test(n) ? this.state[n] = [] : /count|total|index|id|size|length|number|num/.test(n) ? this.state[n] = 0 : /show|hide|is|has|can|should|valid|enable|subscribed/.test(n) ? this.state[n] = !1 : /user|config|form|settings/.test(n) ? this.state[n] = {} : this.state[n] = void 0); const a = e.match(/([\w$][\w\d$]*(?:\.[\w$][\w\d$]*)+)/); if (a) { const e = a[1].split("."), t = e[0]; if (s.includes(t)) return; if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(t)) return; let i = this.state; for (let t = 0; t < e.length; t++) { const s = e[t]; s in i ? t < e.length - 1 && "object" != typeof i[s] && (i[s] = {}) : i[s] = t === e.length - 1 ? void 0 : {}, i = i[s] } } } safeSetArrayVariable(e, t) { try { this.state[e] = t } catch (i) { Object.defineProperty(this.state, e, { value: t, writable: !0, configurable: !0, enumerable: !0 }) } } } class s { constructor(e) { this.initBlocks = e } parse(e) { if (!e) return null; if (11 === e.nodeType) { const t = { tag: "fragment", attrs: {}, directives: {}, subDirectives: {}, children: [] }; return e.childNodes.forEach((e => { const i = this.parse(e); i && t.children.push(i) })), t } if (3 === e.nodeType) return { type: "text", text: e.textContent }; if (1 !== e.nodeType) return null; const t = e.tagName.toLowerCase(); if ("init" === t) return this.initBlocks.push(e.textContent), null; if ("no" === t) return { tag: "no", attrs: {}, directives: {}, subDirectives: {}, children: [], rawContent: e.innerHTML }; const i = { tag: t, attrs: {}, directives: {}, subDirectives: {}, children: [] }; for (const t of Array.from(e.attributes)) if (t.name.startsWith("@")) { const e = t.name.split(":"); if (2 === e.length) { const [s, r] = e; i.subDirectives[s] = i.subDirectives[s] || {}, i.subDirectives[s][r] = t.value } else i.directives[t.name] = t.value } else i.attrs[t.name] = t.value; return e.childNodes && e.childNodes.length > 0 && e.childNodes.forEach((e => { const t = this.parse(e); t && i.children.push(t) })), i } } class r { constructor() { this.components = {}, this.cache = {}, this.loadingComponents = new Map } component(e, t) { this.components[e] = t } async loadExternalComponent(e) { if (this.cache[e]) return this.cache[e]; if (this.loadingComponents.has(e)) return this.loadingComponents.get(e); const t = this._fetchComponent(e); this.loadingComponents.set(e, t); try { const i = await t; return this.cache[e] = i, i } catch (e) { return null } finally { this.loadingComponents.delete(e) } } async _fetchComponent(e) { const t = await fetch(e); if (!t.ok) throw new Error(`HTTP ${t.status}: ${t.statusText}`); return await t.text() } getComponent(e) { return this.components[e] } getCachedComponent(e) { return this.cache[e] } isLoading(e) { return this.loadingComponents.has(e) } } class n { constructor(e, t) { this.state = e, this.watchers = {}, this._prevValues = {}, this._historyValues = {}, this._watcherOneShotFired = {}, this._watcherTypes = {}, this.renderCallback = t, this.watchersReady = !1, this._isUpdating = !1, this._renderTimeout = null } _safeStringify(e) { const t = new WeakSet; try { return JSON.stringify(e, (function (e, i) { if ("object" == typeof i && null !== i) { if (t.has(i)) return "[Circular]"; t.add(i) } return "_ayishaInstance" === e ? "[AyishaInstance]" : i })) } catch (t) { return String(e) } } makeReactive() { Object.defineProperty(this.state, "_historyValues", { value: this._historyValues, enumerable: !1, writable: !0, configurable: !0 }), Object.defineProperty(this.state, "_ayishaReactivity", { value: this, enumerable: !1, writable: !0, configurable: !0 }), Object.defineProperty(this.state, "_prevValues", { value: this._prevValues, enumerable: !1, writable: !0, configurable: !0 }); const e = this.renderCallback, t = (t, i) => { if (!Array.isArray(t) || t._ayishaWrapped) return t; return ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach((i => { if ("function" == typeof t[i]) { const s = t[i]; t[i] = function (...t) { const i = s.apply(this, t); return "function" == typeof e && e(), i } } })), Object.defineProperty(t, "_ayishaWrapped", { value: !0, enumerable: !1, writable: !1, configurable: !1 }), t }; return this.state = new Proxy(this.state, { set: (e, i, s) => { if (Array.isArray(s) && (s = t(s)), this._isUpdating) return e[i] = s, !0; e._prevValues || (e._prevValues = {}), e._prevValues[i] = e[i], this._historyValues[i] || (this._historyValues[i] = []), Object.prototype.hasOwnProperty.call(e, i) && (this._historyValues[i].push(e[i]), this._historyValues[i].length > 20 && this._historyValues[i].shift()); const r = e[i]; return this._safeStringify(r) === this._safeStringify(s) ? (e[i] = s, !0) : (this._isUpdating = !0, e[i] = s, this.watchersReady && this.watchers[i] && ("oneShot" === this._watcherTypes[i] ? this._watcherOneShotFired[i] || (this._watcherOneShotFired[i] = !0, this._prevValues[i] = s, this.watchers[i].forEach((e => { try { e(s) } catch (e) { } }))) : this._safeStringify(this._prevValues[i]) !== this._safeStringify(s) && (this._prevValues[i] = s, this.watchers[i].forEach((e => { try { e(s) } catch (e) { } })))), this._renderTimeout && clearTimeout(this._renderTimeout), this._renderTimeout = setTimeout((() => { this._isUpdating = !1, this._renderTimeout = null, this.renderCallback() }), 10), !0) }, get: (e, i) => { const s = e[i]; return Array.isArray(s) ? t(s) : s } }), this.state } addWatcher(e, t, i = {}) { this.watchers[e] = this.watchers[e] || [], e in this._prevValues || (this._prevValues[e] = this.state[e]), i.oneShot ? (this._watcherTypes[e] = "oneShot", this._watcherOneShotFired[e] = !1) : this._watcherTypes[e] = "reactive", this.watchers[e].push(t) } enableWatchers() { this.watchersReady = !0, Object.keys(this._watcherOneShotFired).forEach((e => { this._watcherOneShotFired[e] = !1 })) } } class a { constructor(e, t) { this.state = e, this.renderCallback = t } setupRouting() { let e = location.pathname.replace(/^\//, "") || ""; e && "index.html" !== e || (history.replaceState({}, "", "/"), e = ""), this.state._currentPage || (this.state._currentPage = e), window.addEventListener("popstate", (() => { const e = location.pathname.replace(/^\//, "") || ""; this.state._currentPage = e, this.renderCallback() })) } setupCurrentPageProperty() { const e = this; let t = this.state._currentPage; Object.defineProperty(this.state, "_currentPage", { get: () => t, set(i) { if (t !== i) { t = i; const s = i ? "/" + i : "/"; history.pushState({}, "", s), e.renderCallback() } } }) } navigate(e) { e.startsWith("/") ? this.state._currentPage = e.substring(1) : this.state._currentPage = e } } class o { constructor(e) { this.evaluator = e, this.pendingFetches = {}, this.lastFetchUrl = {}, this.fetched = {}, this.readyPromise = {} } setupFetch(e, t, i, s, r) { let n = this.evaluator.evalExpr(e, i, s); if (void 0 === n && (n = e.replace(/\{([^}]+)\}/g, ((e, t) => { const r = this.evaluator.evalExpr(t, i, s); return null != r ? r : "" }))), null == n && (n = e), !n) return Promise.resolve(void 0); /^https?:\/\//.test(n) || (n = n.replace(/\/+$/, ""), n = n.replace(/\?$/, ""), n = n.replace(/\?&/, "?"), n = n.replace(/\?$/, ""), n = n.replace(/\&+$/, ""), n = n.replace(/\?page=(&|$)/, "?").replace(/\?$/, ""), n = n.replace(/\/\//g, "/"), n.startsWith("/") || (n = "/" + n), n = location.origin + n); const a = `${n}::${t}`; if (!r && !s && this.lastFetchUrl[a]) return this.readyPromise[a] ? void 0 : (this.readyPromise[a] = Promise.resolve(this.evaluator.state[t]), this.readyPromise[a]); if (!r && this.lastFetchUrl[a] && JSON.stringify(this.lastFetchUrl[a]) === JSON.stringify({ url: n, value: this.evaluator.state[t] })) return this.readyPromise[a] ? void 0 : (this.readyPromise[a] = Promise.resolve(this.evaluator.state[t]), this.readyPromise[a]); if (this.pendingFetches[a]) return Promise.resolve(this.evaluator.state[t]); t && "string" == typeof t && t in this.evaluator.state && (this.evaluator.state[t] = null), this.readyPromise[a] && delete this.readyPromise[a], this.pendingFetches[a] = !0, this.lastFetchUrl[a] = { url: n, value: this.evaluator.state[t] }, this.pendingFetches[a] = !0, this.lastFetchUrl[t] = n, t in this.evaluator.state || (this.evaluator.state[t] = null); let o = "GET", l = null, c = null; if (i && i._vNode) { let e = null; if (i._vNode.directives && i._vNode.directives["@method"] ? e = i._vNode.directives["@method"] : i._vNode.subDirectives && i._vNode.subDirectives["@method"] && (e = i._vNode.subDirectives["@method"]), e) { let t = this.evaluator.evalExpr(e, i, s); o = "string" == typeof t && "" !== t.trim() ? t.toUpperCase() : "string" == typeof e && "" !== e.trim() ? e.trim().toUpperCase() : "GET" } i._vNode.directives && i._vNode.directives["@payload"] && (l = this.evaluator.evalExpr(i._vNode.directives["@payload"], i, s)), i._vNode.directives && i._vNode.directives["@headers"] && (c = this.evaluator.evalExpr(i._vNode.directives["@headers"], i, s)) } const d = { method: o }; let h = {}; null != l && o && !["GET", "HEAD"].includes(o.toUpperCase()) && ("object" == typeof l ? (d.body = JSON.stringify(l), h["Content-Type"] = "application/json") : d.body = l), c && "object" == typeof c && (h = { ...h, ...c }), Object.keys(h).length > 0 && (d.headers = h); return fetch(n, d).then((e => { if (!e.ok) { this.fetched[n] || (this.fetched[n] = {}), this.fetched[n].error = `${e.status} ${e.statusText || "errore di rete"}`; let t = "_error"; return i && i._vNode && i._vNode.directives && i._vNode.directives["@error"] && (t = i._vNode.directives["@error"] || "_error"), e.text().then((i => { let s; try { s = JSON.parse(i) } catch (t) { s = i || `${e.status} ${e.statusText || "errore di rete"}` } const r = { error: s && s.error ? s.error : `${e.status} ${e.statusText}`, details: s && s.details ? s.details : s }; throw this.evaluator.state._error = r, window._error = r, "_error" !== t && (this.evaluator.state[t] = r, window[t] = r), new Error(`${e.status} ${e.statusText}`) })) } return e.json().catch((() => e.text())) })).then((e => { const s = this.evaluator.state[t]; JSON.stringify(s) === JSON.stringify(e) || (this.evaluator.state[t] = e), this.fetched[n] && delete this.fetched[n].error, this.evaluator.state._error = null; let r = "_error"; return i && i._vNode && i._vNode.directives && i._vNode.directives["@error"] && (r = i._vNode.directives["@error"] || "_error"), "_error" !== r && (this.evaluator.state[r] = null), e })).catch((e => { this.fetched[n] || (this.fetched[n] = {}), this.fetched[n].error = e.message; let t = "_error"; i && i._vNode && i._vNode.directives && i._vNode.directives["@error"] && (t = i._vNode.directives["@error"] || "_error"), this.evaluator.state._error = { error: e && e.message ? e.message : e || "Errore sconosciuto", details: e && e.stack ? e.stack : void 0 }, "_error" !== t && (this.evaluator.state[t] = this.evaluator.state._error) })).finally((() => { this.pendingFetches[a] = !1 })) } } class l { constructor() { this.helpTexts = { "@error": 'Esempio: <div @fetch="url" @error="myErrorVar"></div> (variabile dove viene salvato l\'errore della fetch, di default _error)', "@when": 'Esempio: <span @when="condizione" @do="azione"></span> oppure <span @when="condizione" @go="pagina"></span>', "@do": 'Esempio: <span @when="condizione" @do="azione"></span>', "@go": 'Esempio: <span @when="condizione" @go="pagina"></span>', "@wait": 'Esempio: <span @when="condizione" @wait="1000" @go="pagina"></span>', "@if": 'Esempio: <div @if="condizione">Mostra se condizione è true</div>', "@not": 'Esempio: <div @not="condizione">Mostra se condizione è false</div>', "@show": 'Esempio: <div @show="condizione">Mostra se condizione è true</div>', "@hide": 'Esempio: <div @hide="condizione">Nasconde se condizione è true</div>', "@for": 'Esempio: <li @for="item in items">{{item}}</li> o <li @for="i, item in items">{{i}}: {{item}}</li>', "@model": 'Esempio: <input @model="nome">', "@form": 'Esempio: <form @form="nomeForm">...<input @model="campo">...</form> Aggrega tutti i campi @model in state[nomeForm] e calcola la validità globale in _validate[nomeForm] (true/false/null)', "@file": 'Esempio: <input type="file" @file="pic"> (salva il file caricato come base64 nella variabile pic)', "@files": 'Esempio: <input type="file" multiple @files="gallery"> (salva tutti i file caricati come base64 in un array nella variabile gallery, aggiungendo se già presenti)', "@click": 'Esempio: <button @click="state.count++">Aumenta</button>', "@fetch": 'Esempio: <div @fetch="\'url\'" @method="\'POST\'" @payload="{foo:1}" @headers="{ Authorization: \'Bearer ...\' }"></div>', "@method": "Esempio: <div @fetch=\"'url'\" @method=\"'POST'\"></div>", "@payload": 'Esempio: <div @fetch="\'url\'" @method="\'POST\'" @payload="{foo:1}"></div>', "@headers": "Esempio: <div @fetch=\"'url'\" @headers=\"{ Authorization: 'Bearer ...' }\"></div>", "@result": 'Esempio: <div @fetch="\'url\'" @result="data">Carica</div>', "@watch": 'Esempio: <div @watch="user"></div>', "@text": 'Esempio: <span @text="nome"></span>', "@date": 'Esempio: <li @date="data"></li> (formatta una data ISO come "1 agosto 2025, 08:37")', "@dateonly": 'Esempio: <li @dateonly="data"></li> (mostra solo giorno, mese e anno)', "@time": 'Esempio: <li @time="data"></li> (mostra solo ora e minuti)', "@class": 'Esempio: <div @class="{rosso: condizione}"></div>', "@style": "Esempio: <div @style=\"{color:'red'}\"></div>", "@validate": 'Esempio: <input @validate="required,minLength:3">', "@link": 'Esempio: <a @link="pagina">Vai</a>', "@page": 'Esempio: <div @page="home">Solo su home</div>', "@component": 'Esempio: <component @src="comp.html"></component>', "@set": 'Esempio: <button @set:click="foo=1"></button>', "@key": 'Esempio: <li @for="item in items" @key="item.id"></li>', "@src": 'Esempio: <component @src="comp.html"></component>', "@switch": 'Esempio: <div @switch="valore"><div @case="1">Uno</div><div @default>Altro</div></div>', "@case": 'Esempio: <div @case="1">Uno</div>', "@default": "Esempio: <div @default>Altro</div>", "@source": 'Esempio: <div @source="items" @map="item => item*2" @result="doppio"></div>', "@map": 'Esempio: <div @source="items" @map="item => item*2"></div>', "@filter": 'Esempio: <div @source="items" @filter="item > 0"></div>', "@reduce": 'Esempio: <div @source="items" @reduce="(acc, item) => acc+item" @initial="0"></div>', "@initial": 'Esempio: <div @source="items" @reduce="(acc, item) => acc+item" @initial="0"></div>', "@animate": 'Esempio: <div @animate="fade-in"></div>', "@state": "Esempio: <div @state></div> (renderizza lo stato corrente come JSON)", "@log": "Esempio: <div @log></div> (mostra il log delle direttive sull'elemento)", "@hover": 'Esempio: <div @hover="doSomething()"></div>', no: "Esempio: <no>{{nome}}</no> (mostra contenuto senza interpolazione)", "@text:hover": "Esempio: <div @text:hover=\"'Testo hover'\"></div>", "@text:click": "Esempio: <div @text:click=\"'Testo click'\"></div>", "@text:input": 'Esempio: <input @text:input="nome">', "@text:focus": 'Esempio: <input @text:focus="nome">', "@class:focus": 'Esempio: <input @class:focus="{rosso:true}">', "@class:hover": 'Esempio: <div @class:hover="{rosso: condizione}"></div>', "@class:click": 'Esempio: <div @class:click="{rosso: condizione}"></div>', "@class:input": 'Esempio: <input @class:input="{rosso: condizione}">', "@class:change": 'Esempio: <input @class:change="{rosso: condizione}">', "@fetch:click": 'Esempio: <button @fetch:click="\'url\'" @result="data"></button>', "@fetch:hover": 'Esempio: <button @fetch:hover="\'url\'" @result="data"></button>', "@fetch:input": 'Esempio: <input @fetch:input="\'url\'" @result="data">', "@fetch:change": 'Esempio: <input @fetch:change="\'url\'" @result="data">', "@model:input": 'Esempio: <input @model:input="nome">', "@model:change": 'Esempio: <input @model:change="nome">', "@model:focus": 'Esempio: <input @model:focus="nome">', "@model:blur": 'Esempio: <input @model:blur="nome">', "@set:change": "Esempio: <input @set:change=\"foo='bar'\">", "@set:click": 'Esempio: <button @set:click="foo=1"></button>', "@set:input": "Esempio: <input @set:input=\"foo='bar'\">", "@set:focus": "Esempio: <input @set:focus=\"foo='bar'\">", "@set:blur": "Esempio: <input @set:blur=\"foo='bar'\">", "@focus": 'Esempio: <input @focus="doSomething()">', "@blur": 'Esempio: <input @blur="doSomething()">', "@change": 'Esempio: <input @change="doSomething()">', "@input": 'Esempio: <input @input="doSomething()">', "@prev": 'Esempio: <div @prev></div> (mostra valore attuale e precedente dello state)\n<div @prev="foo"></div> (solo per foo)', "@then": 'Esegui una o più espressioni dopo tutte le altre direttive su questo nodo. Esempio: <div @then="foo=1;;bar=2"></div>', "@finally": 'Esegui una o più espressioni dopo tutto, inclusi @then. Esempio: <div @finally="foo=1;;bar=2"></div>' } } getHelp(e) { return this.helpTexts[e] || "" } isValidDirective(e) { return this.helpTexts.hasOwnProperty(e) } } class c { constructor(e) { this.errorBus = e } showAyishaError(e, t, i) { if (!e) return; let s = e.parentNode && e.parentNode.querySelector(".ayisha-error-banner"); s ? s.innerHTML = `<b>Errore JS:</b> ${t.message}<br><code>${i}</code>` : (s = document.createElement("div"), s.className = "ayisha-error-banner", s.style.background = "#c00", s.style.color = "#fff", s.style.padding = "0.5em 1em", s.style.margin = "0.5em 0", s.style.borderRadius = "4px", s.style.fontWeight = "bold", s.style.border = "1px solid #900", s.style.position = "relative", s.style.zIndex = "1000", s.innerHTML = `<b>Errore JS:</b> ${t.message}<br><code>${i}</code>`, e.parentNode && e.parentNode.insertBefore(s, e.nextSibling)), this.errorBus && this.errorBus.report(t, { expr: i, el: e }) } createErrorElement(e) { const t = document.createElement("div"); return t.className = "ayisha-directive-error", t.style.background = "#c00", t.style.color = "#fff", t.style.padding = "1em", t.style.margin = "0.5em 0", t.style.borderRadius = "4px", t.style.fontWeight = "bold", t.style.border = "1px solid #900", t.innerHTML = e, this.errorBus && this.errorBus.report(new Error(e), { type: "createErrorElement", message: e }), t } createWarningElement(e) { const t = document.createElement("div"); return t.className = "ayisha-directive-warning", t.style.background = "#ffeb3b", t.style.color = "#333", t.style.padding = "1em", t.style.margin = "0.5em 0", t.style.borderRadius = "4px", t.style.fontWeight = "bold", t.style.border = "1px solid #e0c200", t.innerHTML = e, t } } class d { constructor(e, t) { this.evaluator = e, this.renderCallback = t, this.modelBindings = [] } static setNestedValidate(e, t, i) { const s = t.split("."); let r = e; for (let e = 0; e < s.length - 1; e++)"object" == typeof r[s[e]] && null !== r[s[e]] || (r[s[e]] = {}), r = r[s[e]]; r[s[s.length - 1]] = i } bindModel(e, t, i) { let s = null; function r(e, t, i) { if (e.includes(".")) { const s = e.split("."), r = s[0]; return t && "object" == typeof t[r] && null !== t[r] ? { root: t[r], path: s.slice(1) } : { root: i, path: s } } return t && "object" == typeof t[e] && null !== t[e] ? { root: t[e], path: [] } : { root: i, path: [e] } } "number" === e.type ? s = "number" : "checkbox" === e.type && (s = "checkbox"); const { root: n, path: a } = r(t, i, this.evaluator.state); let o = n; if (a.length > 0) { for (let e = 0; e < a.length - 1; e++)"object" == typeof o[a[e]] && null !== o[a[e]] || (o[a[e]] = {}), o = o[a[e]]; const t = a[a.length - 1]; "number" === e.type ? "number" != typeof o[t] && (o[t] = 0) : "checkbox" === e.type ? "boolean" != typeof o[t] && (o[t] = !1) : "string" != typeof o[t] && (o[t] = "") } else "object" == typeof o && null !== o || ("number" === e.type ? "number" != typeof this.evaluator.state[t] && (this.evaluator.state[t] = 0) : "checkbox" === e.type ? "boolean" != typeof this.evaluator.state[t] && (this.evaluator.state[t] = !1) : "string" != typeof this.evaluator.state[t] && (this.evaluator.state[t] = "")); const l = () => { const s = this.evaluator.evalExpr(t, i); if ("checkbox" === e.type) e.checked = !!s; else if ("radio" === e.type) e.checked = s === e.value || !0 === s && "true" === e.value || !1 === s && "false" === e.value; else if ("color" === e.type) s && "string" == typeof s && s.match(/^#[0-9A-Fa-f]{6}$/) ? e.value = s : s && "string" == typeof s && s.match(/^[0-9A-Fa-f]{6}$/) ? e.value = "#" + s : e.value = "#000000"; else { const t = null == s ? "" : String(s); e.value !== t && (e.value = t) } }; this.modelBindings.push({ el: e, update: l }), l(); const c = () => { let s = null; "number" === e.type ? s = "number" : "checkbox" === e.type && (s = "checkbox"); const { root: n, path: a } = r(t, i, this.evaluator.state); let o, l = n; if (o = "checkbox" === e.type ? e.checked : "radio" === e.type ? "true" === e.value || "false" !== e.value && e.value : "number" === e.type ? "" === e.value ? void 0 : Number(e.value) : e.value, a.length > 0) { for (let e = 0; e < a.length - 1; e++)"object" == typeof l[a[e]] && null !== l[a[e]] || (l[a[e]] = {}), l = l[a[e]]; l[a[a.length - 1]] = o } else "object" == typeof l && null !== l || (this.evaluator.state[t] = o); this.renderCallback() }; "checkbox" === e.type || "radio" === e.type ? e.addEventListener("change", c) : e.addEventListener("input", c) } bindValidation(e, t, i = null) { const s = []; let r = "", n = !1; for (let e = 0; e < t.length; e++) { const i = t[e]; "^" !== i || n ? "$" === i && n ? (n = !1, r += i, s.push(r.trim()), r = "") : "," !== i || n ? r += i : (r.trim() && s.push(r.trim()), r = "") : (n = !0, r += i) } for (let e = 0; e < s.length; e++)s[e].includes("=") && (s[e] = s[e].replace("=", ":")); if (r.trim() && s.push(r.trim()), !i) return; this.evaluator.state._validate || (this.evaluator.state._validate = {}), d.setNestedValidate(this.evaluator.state._validate, i, null); const a = i.split("."); let o = this.evaluator.state._validate; for (let e = 0; e < a.length - 1; e++)"object" == typeof o[a[e]] && null !== o[a[e]] || (o[a[e]] = {}), o = o[a[e]]; this.evaluator.state._validate.hasOwnProperty(i) && delete this.evaluator.state._validate[i]; const l = () => { if ("" === e.value || null == e.value) return d.setNestedValidate(this.evaluator.state._validate, i, null), e.classList.remove("invalid"), e.classList.remove("valid"), null; let t = !0; for (const i of s) if (/^\^.*\$$/.test(i)) try { const s = new RegExp(i); if (!s.test(e.value || "")) { t = !1; break } } catch (e) { t = !1; break } else if ("required" === i) { if (!e.value || !e.value.trim()) { t = !1; break } } else if (i.startsWith("minLength:") || i.startsWith("minLength=")) { const s = parseInt(i.split(/:|=/)[1], 10); if (e.value.length < s) { t = !1; break } } else if (i.startsWith("maxLength:") || i.startsWith("maxLength=")) { const s = parseInt(i.split(/:|=/)[1], 10); if (e.value.length > s) { t = !1; break } } else if (i.startsWith("min:")) { const s = parseFloat(i.split(":")[1]), r = parseFloat(e.value); if (isNaN(r) || r < s) { t = !1; break } } else if (i.startsWith("max:")) { const s = parseFloat(i.split(":")[1]), r = parseFloat(e.value); if (isNaN(r) || r > s) { t = !1; break } } else if ("email" === i) { if (!/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(e.value || "")) { t = !1; break } } else if ("phone" === i) { if (!/^\+\d{1,3}\s?\d{3,4}\s?\d{3,4}\s?\d{3,4}$/.test(e.value || "")) { t = !1; break } } else if ("password" === i) { if (!/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/.test(e.value || "")) { t = !1; break } } else if (i.startsWith("regex:")) { let s = i.slice(6); try { if (!new RegExp(s).test(e.value || "")) { t = !1; break } } catch (e) { t = !1; break } } return d.setNestedValidate(this.evaluator.state._validate, i, t), e.classList.toggle("invalid", !t), e.classList.toggle("valid", t && e.value.length > 0), t }; l(), e.addEventListener("input", (() => { l(), this.renderCallback() })), e.addEventListener("blur", l) } updateBindings() { this.modelBindings.forEach((e => e.update())) } clearBindings() { this.modelBindings = [] } } class h { constructor(e, t, i) { this.evaluator = e, this.bindingManager = t, this.errorHandler = i } apply(e, t, i, s, r = null) { } handleSubDirective(e, t, i, s, r, n, a = null) { return !1 } executeExpression(e, t, i = null, s = !0) { return this.evaluator.executeDirectiveExpression(e, t, i, s) } evalExpr(e, t) { return this.evaluator.evalExpr(e, t) } showError(e, t, i) { this.errorHandler.showAyishaError(e, t, i) } } class u extends h { apply(e, t, i, s, r = null) { const n = e.directives["@form"]; if (!n) return; const a = [], o = []; if (function e(t) { t.directives && t.directives["@model"] && (a.push(t.directives["@model"]), t.directives["@validate"] && o.push(t.directives["@model"])), t.children && Array.isArray(t.children) && t.children.forEach(e) }(e), i[n] || (i[n] = {}), a.forEach((e => { try { i[n][e] = this.evaluator.evalExpr(e, t) } catch (t) { i[n][e] = void 0 } })), i._validate || (i._validate = {}), i._validate[n] || (i._validate[n] = null), 0 === o.length) i._validate[n] = null; else { let e = !0; for (const t of o) { if (!1 === i._validate[t]) { e = !1; break } null == i._validate[t] && (e = null) } i._validate[n] = e } r && r.addTask((() => Promise.resolve())) } } class p extends h { apply(e, t, i, s, r = null) { let n = this.evaluator.evalExpr(e.directives["@date"], t), a = this.formatDate(n); s.innerText = a, r && r.markSyncDone() } formatDate(e) { if (!e) return ""; let t; if ("string" == typeof e) t = new Date(e); else { if (!(e instanceof Date)) return String(e); t = e } if (isNaN(t.getTime())) return String(e); return t.toLocaleString(navigator.language || navigator.userLanguage || "it-IT", { year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" }) } } class v extends h { apply(e, t, i, s, r = null) { let n = this.evaluator.evalExpr(e.directives["@dateonly"], t), a = this.formatDateOnly(n); s.innerText = a, r && r.markSyncDone() } formatDateOnly(e) { if (!e) return ""; let t; if ("string" == typeof e) t = new Date(e); else { if (!(e instanceof Date)) return String(e); t = e } return isNaN(t.getTime()) ? String(e) : t.toLocaleDateString(navigator.language || navigator.userLanguage || "it-IT") } } class f extends h { apply(e, t, i, s, r = null) { let n = this.evaluator.evalExpr(e.directives["@time"], t), a = this.formatTime(n); s.innerText = a, r && r.markSyncDone() } formatTime(e) { if (!e) return ""; let t; if ("string" == typeof e) t = new Date(e); else { if (!(e instanceof Date)) return String(e); t = e } return isNaN(t.getTime()) ? String(e) : t.toLocaleTimeString(navigator.language || navigator.userLanguage || "it-IT", { hour: "2-digit", minute: "2-digit" }) } } class g extends h { apply(e, t, i, s, r = null) { const n = e.directives["@if"]; let a = !1; try { a = this.evaluator.evalExpr(n, t) } catch { } s && (s.style.display = a ? "" : "none"), r && r.addTask((() => Promise.resolve())) } } class m extends h { apply(e, t, i, s, r = null) { const n = e.directives["@not"]; let a = !1; try { a = !this.evaluator.evalExpr(n, t) } catch { } s && (s.style.display = a ? "" : "none"), r && r.addTask((() => Promise.resolve())) } } class y extends h { apply(e, t, i, s, r = null) { let n = e.directives["@for"].match(/(\w+),\s*(\w+) in (.+)/); if (n) { const [, s, a, o] = n; let l = this.evaluator.evalExpr(o, t) || []; "object" != typeof l || Array.isArray(l) || (l = Object.values(l)); const c = document.createDocumentFragment(); return l.forEach(((n, l) => { const d = JSON.parse(JSON.stringify(e)); delete d.directives["@for"]; const h = { ...t, [a]: n, [s]: l, [`${a}_index`]: l, [`${a}_ref`]: `${o.split(".")[0]}[${l}]` }, u = i._ayishaInstance._renderVNode(d, h); u && (i._ayishaInstance.directiveManager.applyDirectives(d, h, i, u, r), c.appendChild(u)) })), r && r.addTask((() => Promise.resolve())), c } if (n = e.directives["@for"].match(/(\w+) in (.+)/), n) { const [, s, a] = n; let o = this.evaluator.evalExpr(a, t) || []; "object" != typeof o || Array.isArray(o) || (o = Object.values(o)); const l = a.split(".")[0], c = a.includes(".filter"), d = document.createDocumentFragment(); return o.forEach(((n, a) => { const o = JSON.parse(JSON.stringify(e)); delete o.directives["@for"]; let h = a; c && i[l] && (h = i[l].findIndex((e => e.id === n.id || JSON.stringify(e) === JSON.stringify(n)))); const u = { ...t, [s]: n, $index: a, $originalIndex: h, $arrayName: l }, p = i._ayishaInstance._renderVNode(o, u); p && (i._ayishaInstance.directiveManager.applyDirectives(o, u, i, p, r), d.appendChild(p)) })), r && r.addTask((() => Promise.resolve())), d } return null } } class b extends h { apply(e, t, i, s, r = null) { const n = e.directives["@model"]; n && (this.bindingManager.bindModel(s, n, t), r && r.addTask((() => Promise.resolve()))) } handleSubDirective(e, t, i, s, r, n, a = null) { if (["input", "change", "focus", "blur"].includes(r)) { if (this.bindingManager.bindModel(s, n, t), a) { const e = a.addAsyncTask(); s.addEventListener(r, (() => { e && e() })) } return !0 } return !1 } } class w { static setNested(e, t, i) { const s = t.split("."); let r = e; for (let e = 0; e < s.length - 1; e++) { const t = s[e].match(/(\w+)\[(\d+)\]/); if (t) { const e = t[1], i = parseInt(t[2], 10); Array.isArray(r[e]) || (r[e] = []), r[e][i] || (r[e][i] = {}), r = r[e][i] } else "object" == typeof r[s[e]] && null !== r[s[e]] || (r[s[e]] = {}), r = r[s[e]] } const n = s[s.length - 1], a = n.match(/(\w+)\[(\d+)\]/); if (a) { const e = a[1], t = parseInt(a[2], 10); Array.isArray(r[e]) || (r[e] = []), r[e][t] = i } else r[n] = i } static getNested(e, t) { const i = t.split("."); let s = e; for (let e = 0; e < i.length; e++) { const t = i[e].match(/(\w+)\[(\d+)\]/); if (t) { const e = t[1], i = parseInt(t[2], 10); if (!Array.isArray(s[e])) return; s = s[e][i] } else { if ("object" != typeof s || null === s) return; s = s[i[e]] } } return s } } class x extends h { apply(e, t, i, s, r = null) { const n = e.directives["@file"]; n && "INPUT" === s.tagName && "file" === s.type && s.addEventListener("change", (e => { const t = s.files && s.files[0]; if (!t) return w.setNested(i, n, null), void (r && r.addTask((() => Promise.resolve()))); const a = new FileReader; a.onload = function (e) { w.setNested(i, n, e.target.result), r && r.addTask((() => Promise.resolve())) }, a.readAsDataURL(t) })) } handleSubDirective() { return !1 } } class _ extends h { apply(e, t, i, s, r = null) { const n = e.directives["@files"]; n && "INPUT" === s.tagName && "file" === s.type && s.addEventListener("change", (e => { const t = s.files; if (!t || 0 === t.length) return w.setNested(i, n, []), void (r && r.addTask((() => Promise.resolve()))); let a = 0; const o = []; for (let e = 0; e < t.length; e++) { const s = new FileReader; s.onload = function (s) { if (o[e] = s.target.result, a++, a === t.length) { n.split(".").pop().match(/\[(\d+)\]$/) ? w.setNested(i, n, o[0] || null) : w.setNested(i, n, o), r && r.addTask((() => Promise.resolve())) } }, s.readAsDataURL(t[e]) } })) } handleSubDirective() { return !1 } } class E extends h { apply(e, t, i, s, r = null) { const n = e.directives["@hide"]; let a = !1; try { a = this.evaluator.evalExpr(n, t) } catch { } s && (s.style.display = a ? "none" : ""), r && r.addTask((() => Promise.resolve())) } } class $ extends h { apply(e, t, i, s, r = null) { const n = e.directives["@text"]; if (n && !e.subDirectives?.["@text"]) try { if (this.evaluator.hasMultipleAssignments(n)) this.executeExpression(n, t, null, !1); else { const e = this.evalExpr(n, t); s.textContent = this.formatTextValue(e) } r && r.addTask((() => Promise.resolve())) } catch (e) { s.textContent = `[Error: ${e.message}]` } } formatTextValue(e) { return void 0 === e ? "" : null === e ? "null" : String(e) } handleSubDirective(e, t, i, s, r, n, a = null) { switch (s._ayishaOriginalText || (e.children && e.children.length > 0 ? s._ayishaOriginalText = e.children.filter((e => "text" === e.type)).map((e => e.text)).join("") : s._ayishaOriginalText = s.textContent || s.innerText || ""), r) { case "click": const e = a ? a.addAsyncTask() : null; return s.addEventListener("click", (i => { const r = this.evalExpr(n, t, i); s.textContent = this.formatTextValue(r), e && e() })), !0; case "hover": return s.addEventListener("mouseover", (e => { const i = this.evalExpr(n, t, e); s.textContent = this.formatTextValue(i) })), s.addEventListener("mouseout", (() => { s.textContent = s._ayishaOriginalText })), !0; case "input": case "focus": case "blur": const i = a ? a.addAsyncTask() : null; return s.addEventListener(r, (e => { const r = this.evalExpr(n, t, e); s.textContent = this.formatTextValue(r), i && i() })), !0; default: return !1 } } } class S extends h { apply(e, t, i, s, r = null) { const n = e.directives["@class"]; if (!n || e.subDirectives?.["@class"]) return; let a = {}; try { let e = this.evalExpr(n, t); if ("string" == typeof e) { let i = e.trim(); (i.startsWith('"') && i.endsWith('"') || i.startsWith("'") && i.endsWith("'")) && (i = i.slice(1, -1)), i.startsWith("{") && i.endsWith("}") ? (i = i.slice(1, -1), i.split(",").forEach((e => { let [i, s] = e.split(":"); if (i && void 0 !== s) { i = i.trim().replace(/^['"]|['"]$/g, ""); try { s = this.evaluator.evalExpr(s.trim(), t) } catch { s = !!s.trim() } a[i] = !!s } }))) : a = { [i]: !0 } } else "object" == typeof e && null !== e && (a = e) } catch (e) { a = {} } Object.keys(a).forEach((e => { s.classList.remove(e) })), Object.entries(a).forEach((([e, t]) => { s.classList.toggle(e, !!t) })), s.setAttribute("class", s.className), r && r.addTask((() => Promise.resolve())) } handleSubDirective(e, t, i, s, r, n, a = null) { const o = () => { try { return this.evalExpr(n, t) || {} } catch (e) { return {} } }; switch (r) { case "hover": return s.addEventListener("mouseover", (() => { const e = o(); Object.entries(e).forEach((([e, t]) => { t && s.classList.add(e) })) })), s.addEventListener("mouseout", (() => { const e = o(); Object.entries(e).forEach((([e, t]) => { t && s.classList.remove(e) })) })), !0; case "focus": return s.addEventListener("focus", (() => { const e = o(); Object.entries(e).forEach((([e, t]) => { t && s.classList.add(e) })) })), s.addEventListener("blur", (() => { const e = o(); Object.entries(e).forEach((([e, t]) => { t && s.classList.remove(e) })) })), !0; case "click": const e = a ? a.addAsyncTask() : null; return s.addEventListener("click", (() => { const t = o(); Object.entries(t).forEach((([e, t]) => { t && s.classList.toggle(e) })), e && e() })), !0; case "input": const t = a ? a.addAsyncTask() : null; return s.addEventListener("input", (() => { const e = o(); Object.entries(e).forEach((([e, t]) => { t && s.classList.add(e) })), t && t() })), s.addEventListener("blur", (() => { const e = o(); Object.entries(e).forEach((([e, t]) => { t && s.classList.remove(e) })) })), !0; default: return !1 } } } class k extends h { apply(e, t, i, s, r = null) { const n = e.directives["@style"]; if (n) try { const e = this.evalExpr(n, t) || {}; "object" != typeof e || null === e || Array.isArray(e) || Object.entries(e).forEach((([e, t]) => { "string" == typeof e && e.trim() && (s.style[e] = t) })), r && r.addTask((() => Promise.resolve())) } catch (e) { } } } class A extends h { apply(e, t, i, s, r = null) { const n = e.directives["@click"]; if (!n) return; !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const a = r ? r.addAsyncTask() : null; s.addEventListener("click", (e => { this.handleClick(e, n, t, i, s), a && a() })) } handleClick(e, t, i, s, r) { "BUTTON" === r.tagName && e.preventDefault(); try { let r = t; this.evaluator.hasInterpolation(t) && (r = this.evaluator.evalAttrValue(t, i)); const n = r.replace(/\bstate\./g, ""); if (this.handleSpecialClickPatterns(n, i, s)) return; this.executeExpression(n, i, e); const a = /([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*([^;,]+)/g; let o; for (; null !== (o = a.exec(n));) { const e = o[1].trim(); let t; if (void 0 !== i[e]) t = i[e]; else try { t = this.evaluator.evalExpr(o[2].trim(), i) } catch { t = o[2].trim() } s[e] = t } setTimeout((() => window.ayisha && window.ayisha.render()), 0); const l = /([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*([^;]+)/g; let c; for (; null !== (c = l.exec(n));) { const e = c[1].trim(); e in s && void 0 !== i[e] && i[e] !== s[e] && (s[e] = i[e], setTimeout((() => window.ayisha && window.ayisha.render()), 0)) } } catch (e) { this.showError(r, e, t) } } handleSpecialClickPatterns(e, t, i) { const s = e.match(/^(\w+)\.(\w+)(\+\+|--|=.+)$/); if (s) return this.handleContextObjectOperation(s, t, i); const r = e.match(/^(\w+)\s*=\s*(\w+)\.filter\((.+)\)$/); if (r) return this.handleFilterOperation(r, t, i); const n = e.match(/^(\w+)\+\+$/); if (n) return this.handleIncrement(n[1], i); const a = e.match(/^(\w+)--$/); if (a) return this.handleDecrement(a[1], i); const o = e.match(/^(\w+)\s*([+\-*\/])=\s*(.+)$/); return !!o && this.handleArithmetic(o, t, i) } handleContextObjectOperation([, e, t, i], s, r) { if (!s || !s[e]) return !1; const n = s[e]; if (n && "object" == typeof n && n.id) return this.updateObjectInState(n, t, i, s, r); if ("++" === i) n[t] = (n[t] || 0) + 1; else if ("--" === i) n[t] = (n[t] || 0) - 1; else if (i.startsWith("=")) { const e = i.substring(1).trim(); n[t] = this.evalExpr(e, s) } return setTimeout((() => window.ayisha?.render()), 0), !0 } updateObjectInState(e, t, i, s, r) { for (const [n, a] of Object.entries(r)) if (Array.isArray(a)) { const o = a.findIndex((t => t && "object" == typeof t && t.id === e.id)); if (-1 !== o) { if ("++" === i) r[n][o][t] = (r[n][o][t] || 0) + 1; else if ("--" === i) r[n][o][t] = (r[n][o][t] || 0) - 1; else if (i.startsWith("=")) { const e = i.substring(1).trim(); r[n][o][t] = this.evalExpr(e, s) } return setTimeout((() => window.ayisha?.render()), 0), !0 } } return !1 } handleFilterOperation([, e, t, i], s, r) { if (i.includes("!==") && e === t) { const t = i.match(/!==\s*(\w+)\.id/); let n = null; if (t) n = s[t[1]]; else for (const [e, t] of Object.entries(s)) if (t && "object" == typeof t && t.id && "users" !== e) { n = t; break } if (n?.id) return r[e] = r[e].filter((e => e.id !== n.id)), setTimeout((() => window.ayisha?.render()), 0), !0 } return !1 } handleIncrement(e, t) { return e in t || (t[e] = 0), t[e] = (Number(t[e]) || 0) + 1, setTimeout((() => window.ayisha?.render()), 0), !0 } handleDecrement(e, t) { return t[e] = (Number(t[e]) || 0) - 1, setTimeout((() => window.ayisha?.render()), 0), !0 } handleArithmetic([, e, t, i], s, r) { let n = Number(r[e]) || 0, a = Number(this.evalExpr(i, s)) || 0; switch (t) { case "+": r[e] = n + a; break; case "-": r[e] = n - a; break; case "*": r[e] = n * a; break; case "/": r[e] = 0 !== a ? n / a : n; break }return setTimeout((() => window.ayisha?.render()), 0), !0 } handleSubDirective(e, t, i, s, r, n, a = null) { if ("click" === r) { const e = a ? a.addAsyncTask() : null; return s.addEventListener("click", (r => { this.handleClick(r, n, t, i, s), e && e() })), !0 } return !1 } } class T extends h { constructor(e, t, i, s) { super(e, t, i), this.fetchManager = s } apply(e, t, i, s, r = null) { const n = e.directives["@fetch"]; if (!n) return; if (e.subDirectives?.["@fetch"] || e.directives["@when"]) return; const a = this.evaluator.autoVarExpr(n), o = e.directives["@result"] || "result", l = Object.assign({}, t, { _vNode: e }), c = this.fetchManager.setupFetch(a, o, l); r && c && "function" == typeof c.then && r.addTask(c.then((e => (l._eventResult = e, e)))), e.directives["@watch"] && this.handleWatchDirective(e, a, o) } handleSubDirective(e, t, i, s, r, n, a = null) { const o = "hover" === r ? "mouseover" : r, l = a ? a.addAsyncTask() : null; return s.addEventListener(o, (i => { const r = e.directives["@result"] || "result", a = Object.assign({}, t, { _vNode: e }); try { let e = this.evaluator.evalExpr(n, a); void 0 === e && (e = n); const t = this.fetchManager.setupFetch(e, r, a, i, !0); t ? t.then((e => { a._eventResult = e })).finally((() => { l && l() })) : l && l() } catch (e) { this.showError(s, e, n), l && l() } })), !0 } handleWatchDirective(e, t, i) { e.directives["@watch"].split(",").forEach((e => { const s = (e = e.trim()).match(/^([\w$]+)\s*=>\s*(.+)$/) || e.match(/^([\w$]+)\s*:\s*(.+)$/); if (s) { const e = s[1], t = s[2]; this.evaluator.ensureVarInState(t), window.ayisha.addWatcher(e, (e => { try { this.executeExpression(t, {}, { newVal: e }, !0) } catch (e) { } }), { oneShot: !0 }) } else window.ayisha.addWatcher(e, (() => { this.fetchManager.setupFetch(t, i, void 0, void 0, !0) }), { oneShot: !0 }) })) } } class N extends h { apply(e, t, i, s, r = null) { const n = e.directives["@validate"], a = e.directives["@model"]; s && n && a && this.bindingManager.bindValidation(s, n, a), r && r.addTask((() => Promise.resolve())) } } class C extends h { apply(e, t, i, s, r = null) { if (s) { const r = document.createElement("div"); r.style.backgroundColor = "rgba(0, 0, 0, 0.8)", r.style.color = "#fff", r.style.padding = "1em", r.style.borderRadius = "4px", r.style.marginTop = "1em", r.style.overflow = "auto"; let n, a = i, o = "CURRENT & PREVIOUS VALUE"; const l = e.directives["@prev"]; window.ayisha && window.ayisha._reactivity && window.ayisha._reactivity; if ("string" == typeof l && l.trim()) try { a = this.evaluator.evalExpr(l, t), o = `PREV: ${l}`, n = i._prevValues && l in i._prevValues ? i._prevValues[l] : void 0 } catch (e) { a = { error: "Invalid expression", details: e.message }, o = `PREV: ${l}` } else if (i._prevValues) { n = {}; for (const e in i) Object.prototype.hasOwnProperty.call(i, e) && (n[e] = i._prevValues[e]) } function c(e) { if (void 0 === e) return "undefined"; if (null === e) return "null"; try { const t = new WeakSet; return JSON.stringify(e, (function (e, i) { if ("object" == typeof i && null !== i) { if (t.has(i)) return "[Circular]"; t.add(i) } return void 0 === i ? "undefined" : "function" == typeof i ? "[Function]" : "_ayishaInstance" !== e ? i : void 0 }), 2) } catch (t) { try { return String(e) } catch { return "[Unserializable]" } } } const d = document.createElement("h3"); d.textContent = o, d.style.margin = "0.5em 0 2em", d.style.fontSize = "1.1em", d.style.fontWeight = "bold", d.style.color = "#fff", r.appendChild(d); const h = document.createElement("pre"); h.style.margin = "0", h.style.whiteSpace = "pre-wrap", h.style.fontFamily = "monospace"; try { h.textContent = "Current Value:\n" + c(a) + "\n\nPrevious Value:\n" + c(n) } catch (e) { h.textContent = "Error displaying previous value: " + e.message } r.appendChild(h), s.appendChild(r) } r && r.addTask((() => Promise.resolve())) } } class D extends h { apply(e, t, i, s, r = null) { if (s) { const r = document.createElement("div"); r.style.backgroundColor = "rgba(0, 0, 0, 0.8)", r.style.color = "#fff", r.style.padding = "1em", r.style.borderRadius = "4px", r.style.marginTop = "1em", r.style.overflow = "auto"; let n = i, a = "CURRENT STATE"; const o = e.directives["@state"]; if ("string" == typeof o && o.trim()) try { n = this.evaluator.evalExpr(o, t), a = `STATE: ${o}` } catch (e) { n = { error: "Invalid expression", details: e.message }, a = `STATE: ${o}` } function l(e) { const t = new WeakSet; return JSON.parse(JSON.stringify(e, (function (e, i) { if ("object" == typeof i && null !== i) { if (t.has(i)) return; t.add(i) } if ("_ayishaInstance" !== e) return i }))) } void 0 === n && (n = null); const c = document.createElement("h3"); c.textContent = a, c.style.margin = "0.5em 0 2em", c.style.fontSize = "1.1em", c.style.fontWeight = "bold", c.style.color = "#fff", r.appendChild(c); const d = document.createElement("pre"); d.style.margin = "0", d.style.whiteSpace = "pre-wrap", d.style.fontFamily = "monospace"; try { d.textContent = JSON.stringify(l(n), null, 2) } catch (e) { d.textContent = "[Non serializzabile]" } r.appendChild(d), s.appendChild(r) } r && r.addTask((() => Promise.resolve())) } } class L extends h { apply(e, t, i, s, r = null) { s && (s.textContent = "Log: " + JSON.stringify(e.directives, null, 2)), r && r.addTask((() => Promise.resolve())) } } class z extends h { apply(e, t, i, s, r = null) { const n = e.directives["@attr"]; let a = {}; try { a = this.evaluator.evalExpr(n, t) } catch { } s && "object" == typeof a && Object.entries(a).forEach((([e, t]) => { s.setAttribute(e, t) })), r && r.addTask((() => Promise.resolve())) } } class M extends h { apply(e, t, i, s, r = null) { const n = e.directives["@focus"]; if (!n) return; !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const a = r ? r.addAsyncTask() : null; s.addEventListener("focus", (e => { try { this.executeExpression(n, t, e, !0), a && a() } catch (e) { this.showError(s, e, n), a && a() } })) } handleSubDirective(e, t, i, s, r, n, a = null) { if ("focus" === r) { !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const e = a ? a.addAsyncTask() : null; return s.addEventListener("focus", (i => { try { this.executeExpression(n, t, i, !0), e && e() } catch (t) { this.showError(s, t, n), e && e() } })), !0 } return !1 } } class O extends h { apply(e, t, i, s, r = null) { const n = e.directives["@blur"]; if (!n) return; !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const a = r ? r.addAsyncTask() : null; s.addEventListener("blur", (e => { try { this.executeExpression(n, t, e, !0), a && a() } catch (e) { this.showError(s, e, n), a && a() } })) } handleSubDirective(e, t, i, s, r, n, a = null) { if ("blur" === r) { !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const e = a ? a.addAsyncTask() : null; return s.addEventListener("blur", (i => { try { this.executeExpression(n, t, i, !0), e && e() } catch (t) { this.showError(s, t, n), e && e() } })), !0 } return !1 } } class P extends h { apply(e, t, i, s, r = null) { const n = e.directives["@change"]; if (!n) return; !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const a = r ? r.addAsyncTask() : null; s.addEventListener("change", (e => { try { this.executeExpression(n, t, e, !0), a && a() } catch (e) { this.showError(s, e, n), a && a() } })) } handleSubDirective(e, t, i, s, r, n, a = null) { if ("change" === r) { !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const e = a ? a.addAsyncTask() : null; return s.addEventListener("change", (i => { try { this.executeExpression(n, t, i, !0), e && e() } catch (t) { this.showError(s, t, n), e && e() } })), !0 } return !1 } } class I extends h { apply(e, t, i, s, r = null) { const n = e.directives["@input"]; if (!n) return; !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const a = r ? r.addAsyncTask() : null; s.addEventListener("input", (e => { try { this.executeExpression(n, t, e, !0), a && a() } catch (e) { this.showError(s, e, n), a && a() } })) } handleSubDirective(e, t, i, s, r, n, a = null) { if ("input" === r) { !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.trim()) || n.includes("=") || n.includes("<") || n.includes(">") || n.includes("!") || n.includes("&") || n.includes("|") || n.includes("'") || n.includes('"') || n.includes("(") || n.includes(")") || this.evaluator.ensureVarInState(n); const e = a ? a.addAsyncTask() : null; return s.addEventListener("input", (i => { try { this.executeExpression(n, t, i, !0), e && e() } catch (t) { this.showError(s, t, n), e && e() } })), !0 } return !1 } } class V extends h { apply(e, t, i, s, r = null) { const n = e.directives["@do"]; if (!n) return; const a = ["@watch", "@when", "@fetch", "@click", "@input", "@change", "@blur", "@focus", "@hover", "@go", "@set", "@model", "@validate", "@key", "@result", "@then", "@finally", "@error", "@payload", "@headers", "@method", "@page", "@component", "@src", "@state", "@log", "@text", "@class", "@style", "@show", "@hide", "@if", "@for", "@switch", "@case", "@default", "@source", "@map", "@filter", "@reduce", "@initial", "@animate", "@link"]; for (const t of a) if (e.directives[t] && "@do" !== t) return; this.executeExpression(n, t), r && r.addTask((() => Promise.resolve())) } } class j extends h { apply(e, t, i, s, r = null) { const n = e.directives["@when"], a = e.directives["@do"], o = e.directives["@go"], l = e.directives["@wait"]; if (!a && !o) return; const c = `when_${n}_${a || ""}_${o || ""}`; if (window._ayishaWhenLastState || (window._ayishaWhenLastState = {}), !e._ayishaWhenWatcherSetup) { e._ayishaWhenWatcherSetup = !0; const d = this.evaluator.extractDependencies(n); window.ayisha && "function" == typeof window.ayisha.addWatcher && d.forEach((d => { window.ayisha.addWatcher(d, (() => { this._ayishaWhenReactiveTrigger(e, t, i, s, c, n, a, o, l, r) })) })) } this._ayishaWhenReactiveTrigger(e, t, i, s, c, n, a, o, l, r, !0) } _ayishaWhenReactiveTrigger(e, t, i, s, r, n, a, o, l, c = null, d = !1) { let h = !1; try { h = this.evaluator.evalExpr(n, t) } catch (e) { return } const u = !!h; let p = window._ayishaWhenLastState[r]; if ("boolean" != typeof p && (p = !1), u && !p) { let e = !1; const s = () => { if (!e) { e = !0, window._ayishaWhenLastState[r] = !0; try { if (a && this.executeExpression(a, t, null, !1), o) { let e; try { let i = this.evaluator.autoPageName(o); e = this.evaluator.evalExpr(i, t) } catch (t) { e = void 0 } !e && "string" == typeof o && o.trim() && (e = o.trim().replace(/^['"]|['"]$/g, "")), "string" == typeof e && e.length > 0 && i._currentPage !== e && (i._currentPage = e, window && window.history && "function" == typeof window.history.pushState && (window.history.pushState({}, "", "/" + e), window.dispatchEvent(new PopStateEvent("popstate")))) } c && c.addTask((() => Promise.resolve())) } catch (e) { } } }, d = l ? this.parseDelay(l, t, i) : 0; if (d > 0) if (c) { const e = new Promise((e => { setTimeout((() => { let i = !1; try { i = this.evaluator.evalExpr(n, t) } catch { } i ? s() : window._ayishaWhenLastState[r] = !1, e() }), d) })); c.addTask(e) } else setTimeout((() => { let e = !1; try { e = this.evaluator.evalExpr(n, t) } catch { } e ? s() : window._ayishaWhenLastState[r] = !1 }), d); else s() } else !u && p && (window._ayishaWhenLastState[r] = !1) } parseDelay(e, t, i) { try { let i = this.evaluator.evalExpr(e, t); const s = parseInt(i, 10); return isNaN(s) ? 0 : Math.max(0, s) } catch (e) { return 0 } } } class H extends h { apply(e, t, i, s, r = null) { if (e.directives["@when"]) return; let n = e.directives["@go"]; this.evaluator && "function" == typeof this.evaluator.autoPageName && (n = this.evaluator.autoPageName(n)); let a = this.evaluator ? this.evaluator.evalExpr(n, t) : n; if ("string" == typeof a) { let e = this.resolvePath(a); if (i._currentPage = e, window && window.history && "function" == typeof window.history.pushState) { const t = e ? "/" + e : "/"; window.history.pushState({}, "", t), window.dispatchEvent(new PopStateEvent("popstate")) } "function" == typeof window.ayisha?.render && setTimeout((() => window.ayisha.render()), 0) } r && r.addTask((() => Promise.resolve())) } resolvePath(e) { return e ? e.startsWith("/") ? e.substring(1) : e : "" } } class F extends h { apply(e, t, i, s, r = null) { r && r.addTask((() => Promise.resolve())) } } class R extends h { apply(e, t, i, s, r = null) { const n = e.directives["@set"]; if (!n || e._setProcessed) return; let a = n; a = Array.isArray(a) ? a.flat().filter(Boolean) : "string" == typeof a ? a.split(/;;|\n/).map((e => e.trim())).filter(Boolean) : [a], a.forEach((e => { try { const s = /([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=([^=].*)/g; let r; for (; null !== (r = s.exec(e));) { const e = r[1]; e in i && void 0 !== i[e] || (i[e] = this.evaluator.evalExpr(r[2], t)) } } catch (e) { s && s.setAttribute("data-ayisha-set-error", e.message) } })), e._setProcessed = !0, delete e.directives["@set"], r && r.addTask((() => Promise.resolve())) } handleSubDirective(e, t, i, s, r, n, a = null) { if (["click", "input", "change", "focus", "blur"].includes(r)) { const e = a ? a.addAsyncTask() : null; return s.addEventListener(r, (() => { try { this.executeExpression(n, t, null, !0), e && e() } catch (t) { this.showError(s, t, n), e && e() } })), !0 } return !1 } } class W extends h { apply(e, t, i, s, r = null) { r && r.addTask((() => Promise.resolve())) } } class B extends h { apply(e, t, i, s, r = null) { r && r.addTask((() => Promise.resolve())) } } class Z extends h { apply(e, t, i, s, r = null) { s && e.directives["@key"] && s.setAttribute("data-ayisha-key", e.directives["@key"]), r && r.addTask((() => Promise.resolve())) } } class J extends h { apply(e, t, i, s, r = null) { if (s && e.directives["@src"]) { const t = e.directives["@src"], i = window.ayisha?.componentManager?.loadExternalComponent(t).then((e => { e && (s.innerHTML = e) })); r && i && r.addTask(i) } } } class U extends h { apply(e, t, i, s, r = null) { if (s && e.directives["@page"]) { const t = e.directives["@page"]; s.style.display = i._currentPage === t ? "" : "none" } r && r.addTask((() => Promise.resolve())) } } class q extends h { apply(e, t, i, s, r = null) { const n = e.directives["@src"]; if (!n) return this.errorHandler.createErrorElement("Error: <b>&lt;component&gt;</b> requires the <b>@src</b> attribute"); let a = null; try { a = this.evaluator.evalExpr(n, t) } catch (e) { a = n } if (a || (a = n), "string" == typeof a && (a = a.trim()), "string" == typeof a && /^['"].*['"]$/.test(a) && (a = a.slice(1, -1)), !a || "undefined" === a || "null" === a) return this.errorHandler.createErrorElement("Error: Invalid component URL"); a.startsWith("./") && (a = a.substring(2)); const o = window.ayisha?.componentManager; if (o && o.getCachedComponent(a)) { const e = o.getCachedComponent(a), s = document.createElement("div"); s.innerHTML = e, window.ayisha?._processComponentInitBlocks(s); const n = window.ayisha?.parse(s); if (n && n.children) { const e = document.createDocumentFragment(); return n.children.forEach((s => { const r = i._ayishaInstance._renderVNode(s, t); r && e.appendChild(r) })), r && r.addTask((() => Promise.resolve())), e } } if (o && !o.getCachedComponent(a)) { const e = o.loadExternalComponent(a).then((e => { if (e) { const t = document.createElement("div"); t.innerHTML = e, window.ayisha?._processComponentInitBlocks(t), window.ayisha?._isRendering || (clearTimeout(window.ayisha?._componentRenderTimeout), window.ayisha._componentRenderTimeout = setTimeout((() => window.ayisha.render()), 10)) } })).catch((e => { o.cache[a] = `<div class='component-error' style='padding: 10px; background: #ffe6e6; border: 1px solid #ff6b6b; border-radius: 4px; color: #d32f2f;'>Errore: ${e.message}</div>`, window.ayisha?._isRendering || (clearTimeout(window.ayisha?._componentRenderTimeout), window.ayisha._componentRenderTimeout = setTimeout((() => window.ayisha.render()), 10)) })); r && r.addTask(e) } const l = document.createElement("div"); return l.className = "component-loading", l.style.cssText = "padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; color: #6c757d; font-size: 14px; text-align: center;", l.innerHTML = `⏳ Loading component: <code>${a}</code>`, l } } class Q extends h { apply(e, t, i, s, r = null) { const n = this.evaluator.evalExpr(e.directives["@switch"], t); let a = null; for (const s of e.children) if (s.directives) { if (null != s.directives["@case"]) { let e = s.directives["@case"]; if (/^['"].*['"]$/.test(e) && (e = e.slice(1, -1)), String(e) === String(n)) return r && r.addTask((() => Promise.resolve())), i._ayishaInstance._renderVNode(s, t) } null != s.directives["@default"] && (a = s) } return r && r.addTask((() => Promise.resolve())), a ? i._ayishaInstance._renderVNode(a, t) : document.createComment("noswitch") } } class G extends h { apply(e, t, i, s, r = null) { r && r.addTask((() => Promise.resolve())) } } class Y extends h { apply(e, t, i, s, r = null) { r && r.addTask((() => Promise.resolve())) } } class X extends h { apply(e, t, i, s, r = null) { if (s && e.directives["@source"]) { const i = e.directives["@source"], r = this.evaluator?.evalExpr(i, t); s.ayishaSourceData = r } r && r.addTask((() => Promise.resolve())) } } class K extends h { apply(e, t, i, s, r = null) { if (s && e.directives["@map"]) { const i = e.directives["@map"], r = s.ayishaSourceData; if (Array.isArray(r)) try { const e = this.evaluator?.evalExpr(i, t); s.ayishaSourceData = r.map(e) } catch { } } r && r.addTask((() => Promise.resolve())) } } class ee extends h { apply(e, t, i, s, r = null) { if (s && e.directives["@filter"]) { const i = e.directives["@filter"], r = s.ayishaSourceData; if (Array.isArray(r)) try { const e = this.evaluator?.evalExpr(i, t); s.ayishaSourceData = r.filter(e) } catch { } } r && r.addTask((() => Promise.resolve())) } } class te extends h { apply(e, t, i, s, r = null) { if (s && e.directives["@reduce"]) { const i = e.directives["@reduce"], r = e.directives["@initial"], n = s.ayishaSourceData; if (Array.isArray(n)) try { const e = this.evaluator?.evalExpr(i, t); s.ayishaSourceData = n.reduce(e, r) } catch { } } r && r.addTask((() => Promise.resolve())) } } class ie extends h { apply(e, t, i, s, r = null) { r && r.addTask((() => Promise.resolve())) } } class se extends h { apply(e, t, i, s, r = null) { s && e.directives["@animate"] && s.classList.add(e.directives["@animate"]), r && r.addTask((() => Promise.resolve())) } } class re extends h { apply(e, t, i, s, r = null) { if (s && e.directives["@link"]) { const t = r ? r.addAsyncTask() : null; s.addEventListener("click", (s => { s.preventDefault(); const r = e.directives["@link"]; let n = this.resolvePath(r); if (i._currentPage = n, window && window.history && "function" == typeof window.history.pushState) { const e = n ? "/" + n : "/"; window.history.pushState({}, "", e), window.dispatchEvent(new PopStateEvent("popstate")) } setTimeout((() => { window.scrollTo({ top: 0, left: 0, behavior: "smooth" }) }), 10), "function" == typeof window.ayisha?.render && setTimeout((() => window.ayisha.render()), 0), t && t() })) } } resolvePath(e) { return e ? e.startsWith("/") ? e.substring(1) : e : "" } } class ne extends h { apply(e, t, i, s, r = null) { const n = e.directives["@hover"]; if (!n) return; const a = r ? r.addAsyncTask() : null, o = e => { try { this.executeExpression(n, t, e, !0), a && a() } catch (e) { this.showError(s, e, n), a && a() } }; s.addEventListener("mouseover", o), s.addEventListener("mouseout", o) } handleSubDirective(e, t, i, s, r, n, a = null) { if ("hover" === r) { const e = a ? a.addAsyncTask() : null, i = i => { try { this.executeExpression(n, t, i, !0), e && e() } catch (t) { this.showError(s, t, n), e && e() } }; return s.addEventListener("mouseover", i), s.addEventListener("mouseout", i), !0 } return !1 } } const ae = { "@if": g, "@not": m, "@for": y, "@form": u, "@model": b, "@file": x, "@files": _, "@show": class extends h { apply(e, t, i, s, r = null) { const n = e.directives["@show"]; let a = !1; try { a = this.evaluator.evalExpr(n, t) } catch { } s && (s.style.display = a ? "" : "none"), r && r.addTask((() => Promise.resolve())) } }, "@hide": E, "@text": $, "@class": S, "@style": k, "@click": A, "@fetch": T, "@validate": N, "@state": D, "@log": L, "@attr": z, "@focus": M, "@blur": O, "@change": P, "@input": I, "@when": j, "@do": V, "@go": H, "@wait": F, "@set": R, "@then": W, "@finally": B, "@key": Z, "@src": J, "@page": U, "@component": q, "@switch": Q, "@case": G, "@default": Y, "@source": X, "@map": K, "@filter": ee, "@reduce": te, "@initial": ie, "@animate": se, "@link": re, "@prev": C, "@hover": ne, "@date": p, "@dateonly": v, "@time": f }; class oe { constructor(e, t, i, s) { this.directives = new Map, this.evaluator = e, this.bindingManager = t, this.errorHandler = i, this.fetchManager = s, this.initializeDirectives() } initializeDirectives() { this.register("@if", new g(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@not", new m(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@for", new y(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@form", new u(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@model", new b(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@file", new x(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@files", new _(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@hide", new E(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@text", new $(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@date", new p(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@dateonly", new v(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@time", new f(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@class", new S(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@style", new k(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@click", new A(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@fetch", new T(this.evaluator, this.bindingManager, this.errorHandler, this.fetchManager)), this.register("@validate", new N(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@state", new D(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@log", new L(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@attr", new z(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@focus", new M(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@blur", new O(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@change", new P(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@input", new I(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@when", new j(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@do", new V(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@go", new H(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@wait", new F(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@set", new R(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@then", new W(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@finally", new B(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@key", new Z(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@src", new J(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@page", new U(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@component", new q(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@switch", new Q(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@case", new G(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@default", new Y(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@source", new X(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@map", new K(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@filter", new ee(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@reduce", new te(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@initial", new ie(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@animate", new se(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@prev", new C(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@link", new re(this.evaluator, this.bindingManager, this.errorHandler)), this.register("@hover", new ne(this.evaluator, this.bindingManager, this.errorHandler)) } register(e, t) { this.directives.set(e, t) } getDirective(e) { return this.directives.get(e) } applyDirectives(e, t, i, s, r = null) { if (e.directives && e.directives["@watch"] && e.directives["@do"] && window.ayisha && "function" == typeof window.ayisha.addWatcher) { window._ayishaGlobalWatchRegistry || (window._ayishaGlobalWatchRegistry = new Set); let i = null, s = [], r = e; for (; r;) { let e = r.tag || "", t = ""; r.attrs && (t = Object.entries(r.attrs).filter((([e, t]) => "string" == typeof t && !e.startsWith("@"))).map((([e, t]) => `${e}=${t}`)).join(";")); let i = r.directives && r.directives["@for"] ? `@for=${r.directives["@for"]}` : ""; s.push(`${e}|${t}|${i}`), r = r.parent || r._parent || null } s = s.reverse(), i = s.join(">") + "::" + e.directives["@watch"] + "::" + e.directives["@do"], e.directives["@__autoKey"] = i, e.directives["@watch"].split(",").forEach((s => { const r = s.trim(), n = r + "::" + e.directives["@do"] + "::" + i; window._ayishaGlobalWatchRegistry.has(n) || (window._ayishaGlobalWatchRegistry.add(n), window.ayisha.addWatcher(r, (() => { try { window.ayisha.evaluator.executeDirectiveExpression(e.directives["@do"], t, null, !0) } catch (e) { } }), { oneShot: !1 })) })) } Object.keys(e.directives || {}).forEach((n => { if ("@then" === n || "@finally" === n) return; const a = this.getDirective(n); if (a) try { a.apply(e, t, i, s, r) } catch (t) { this.errorHandler.showAyishaError(s, t, e.directives[n]) } })), Object.entries(e.subDirectives || {}).forEach((([n, a]) => { const o = this.getDirective(n); o && Object.entries(a).forEach((([n, a]) => { try { o.handleSubDirective(e, t, i, s, n, a, r) } catch (e) { this.errorHandler.showAyishaError(s, e, a) } })) })) } } class le { constructor(e) { this.evaluator = e, this.startTime = performance.now() } getBaseInfo(e, t) { return { tag: e.tag, timestamp: new Date, executionTime: (performance.now() - this.startTime).toFixed(2) + "ms" } } log(e, t, i) { return this.getBaseInfo(e, t) } } class ce extends le { log(e, t, i) { const s = super.log(e, t, i), r = e.directives["@for"]; let n = {}; try { const e = r.match(/(\w+),\s*(\w+) in (.+)/), i = r.match(/(\w+) in (.+)/); if (e || i) { const s = e ? e[3] : i[2], a = e ? e[2] : i[1], o = e ? e[1] : null, l = this.evaluator.evalExpr(s, t), c = Array.isArray(l), d = c ? l.length : l ? Object.keys(l).length : 0; n = { expression: r, arrayVariable: s, itemVariable: a, indexVariable: o, arrayType: c ? "Array" : "Object", length: d, isEmpty: 0 === d, firstItem: d > 0 ? l[0] : null, status: 0 === d ? "❌ Empty" : `✅ ${d} items`, performance: `${d} items rendered` } } } catch (e) { n = { expression: r, error: `❌ ${e.message}`, status: "❌ Error evaluating" } } return { ...s, type: "@for", data: n } } } class de extends le { constructor(e, t) { super(e), this.fetchManager = t } log(e, t, i) { const s = super.log(e, t, i), r = e.directives["@fetch"], n = e.directives["@result"] || "result"; let a = {}; try { let e = this.evaluator.evalExpr(r, t); e || (e = r); const s = i[n], o = this.fetchManager.fetched[e]?.error, l = this.fetchManager.pendingFetches[`${e}::${n}`]; a = { url: e, method: "GET", resultVariable: n, status: o ? `❌ ${o}` : l ? "⏳ Loading..." : s ? "✅ Success" : "⭕ No data", responseSize: s ? `${JSON.stringify(s).length} chars` : "N/A", hasData: !!s, hasError: !!o, isPending: !!l, lastFetch: this.fetchManager.lastFetchUrl[n] ? "Recently" : "Never" } } catch (e) { a = { url: r, error: `❌ ${e.message}`, status: "❌ Error evaluating URL" } } return { ...s, type: "@fetch", data: a } } } class he extends le { log(e, t, i) { const s = super.log(e, t, i), r = e.directives["@model"], n = e.directives["@validate"]; let a = {}; try { const e = this.evaluator.evalExpr(r, t), s = i._validate?.[r]; a = { variable: r, currentValue: e, valueType: typeof e, isEmpty: !e || "" === e, validation: n ? { rules: n, isValid: s, status: s ? "✅ Valid" : "❌ Invalid" } : null, binding: "✅ Active" } } catch (e) { a = { variable: r, error: `❌ ${e.message}`, status: "❌ Error evaluating" } } return { ...s, type: "@model", data: a } } } class ue extends le { log(e, t, i) { const s = super.log(e, t, i), r = e.directives["@if"] || e.directives["@show"] || e.directives["@hide"], n = e.directives["@if"] ? "@if" : e.directives["@show"] ? "@show" : "@hide"; let a = {}; try { const e = this.evaluator.evalExpr(r, t), i = "@hide" === n ? !e : !!e; a = { condition: r, result: e, isVisible: i, status: i ? "✅ Visible" : "❌ Hidden", evaluation: `${r} → ${e}` } } catch (e) { a = { condition: r, error: `❌ ${e.message}`, status: "❌ Error evaluating" } } return { ...s, type: n, data: a } } } class pe extends le { constructor(e) { super(e), this.clickCount = 0, this.lastClick = null } log(e, t, i) { return { ...super.log(e, t, i), type: "@click", data: { action: e.directives["@click"], clickCount: this.clickCount, lastClick: this.lastClick ? Date.now() - this.lastClick + "ms ago" : "Never", status: "✅ Ready" } } } recordClick() { this.clickCount++, this.lastClick = Date.now() } } class ve extends le { constructor(e) { super(e), this.inputCount = 0, this.lastInput = null } log(e, t, i) { return { ...super.log(e, t, i), type: "@input", data: { action: e.directives["@input"], inputCount: this.inputCount, lastInput: this.lastInput ? Date.now() - this.lastInput + "ms ago" : "Never", status: "✅ Ready" } } } recordInput() { this.inputCount++, this.lastInput = Date.now() } } class fe extends le { constructor(e) { super(e), this.focusCount = 0, this.lastFocus = null } log(e, t, i) { return { ...super.log(e, t, i), type: "@focus", data: { action: e.directives["@focus"], focusCount: this.focusCount, lastFocus: this.lastFocus ? Date.now() - this.lastFocus + "ms ago" : "Never", status: "✅ Ready" } } } recordFocus() { this.focusCount++, this.lastFocus = Date.now() } } class ge extends le { constructor(e) { super(e), this.blurCount = 0, this.lastBlur = null } log(e, t, i) { return { ...super.log(e, t, i), type: "@blur", data: { action: e.directives["@blur"], blurCount: this.blurCount, lastBlur: this.lastBlur ? Date.now() - this.lastBlur + "ms ago" : "Never", status: "✅ Ready" } } } recordBlur() { this.blurCount++, this.lastBlur = Date.now() } } class me extends le { constructor(e) { super(e), this.changeCount = 0, this.lastChange = null } log(e, t, i) { return { ...super.log(e, t, i), type: "@change", data: { action: e.directives["@change"], changeCount: this.changeCount, lastChange: this.lastChange ? Date.now() - this.lastChange + "ms ago" : "Never", status: "✅ Ready" } } } recordChange() { this.changeCount++, this.lastChange = Date.now() } } class ye extends le { constructor(e, t) { super(e), this.componentManager = t } log(e, t, i) { const s = super.log(e, t, i), r = e.directives["@src"]; let n = {}; try { let e = this.evaluator.evalExpr(r, t); if (!e) { const t = r.trim(); e = /^['"].*['"]$/.test(t) ? t.slice(1, -1) : t } const i = this.componentManager.getCachedComponent(e), s = this.componentManager.isLoading(e); n = { source: e, status: s ? "⏳ Loading..." : i ? "✅ Loaded" : "⭕ Not loaded", cached: !!i, isLoading: s, size: i ? `${i.length} chars` : "N/A" } } catch (e) { n = { source: r, error: `❌ ${e.message}`, status: "❌ Error evaluating" } } return { ...s, type: "@component", data: n } } } class be { constructor() { this.logs = [], this.loggers = {}, this.clickLoggers = new WeakMap, this.startTime = performance.now(), this.maxLogs = 100 } initializeLoggers(e, t, i) { this.loggers = { "@for": new ce(e), "@fetch": new de(e, t), "@model": new he(e), "@if": new ue(e), "@show": new ue(e), "@hide": new ue(e), "@click": new pe(e), "@component": new ye(e, i), "@input": new ve(e), "@focus": new fe(e), "@blur": new ge(e), "@change": new me(e) } } addLog(e, t, i, s, r = null) { if (!this.loggers || 0 === Object.keys(this.loggers).length) return; const n = performance.now(), a = { id: Date.now() + Math.random(), timestamp: new Date, tag: t.tag, type: "multi-directive", elementInfo: e, executionTime: (performance.now() - n).toFixed(2) + "ms", directives: [] }; Object.keys(t.directives).forEach((e => { if (this.loggers[e]) try { const r = this.loggers[e].log(t, i, s); a.directives.push({ type: e, data: r.data, status: this._getDirectiveStatus(r.data) }) } catch (t) { a.directives.push({ type: e, data: { error: t.message, status: "❌ Error logging" }, status: "error" }) } else a.directives.push({ type: e, data: { expression: t.directives[e], status: "📋 Untracked directive" }, status: "unknown" }) })), Object.entries(t.subDirectives || {}).forEach((([e, r]) => { Object.keys(r).forEach((n => { if (this.loggers[e]) try { const r = this.loggers[e].log(t, i, s); a.directives.push({ type: `${e}:${n}`, data: r.data, status: this._getDirectiveStatus(r.data), isSubDirective: !0 }) } catch (t) { a.directives.push({ type: `${e}:${n}`, data: { error: t.message, status: "❌ Error logging" }, status: "error", isSubDirective: !0 }) } else a.directives.push({ type: `${e}:${n}`, data: { expression: r[n], status: "📋 Untracked sub-directive" }, status: "unknown", isSubDirective: !0 }) })) })), 0 === a.directives.length && (a.type = "generic", a.directives.push({ type: "generic", data: { message: "Element with @log but no tracked directives", status: "📋 Generic log" }, status: "generic" })), a.overallStatus = this._calculateOverallStatus(a.directives), this.logs.unshift(a), this.logs.length > this.maxLogs && (this.logs = this.logs.slice(0, this.maxLogs)) } _getDirectiveStatus(e) { return e.error ? "error" : e.isPending || e.isLoading ? "loading" : e.status && e.status.includes("✅") ? "success" : e.status && e.status.includes("❌") ? "error" : e.status && e.status.includes("⏳") ? "loading" : "normal" } _calculateOverallStatus(e) { if (!e || 0 === e.length) return "📊 No directives"; const t = e.map((e => e.status)); return t.includes("error") ? "❌ Has Errors" : t.includes("loading") ? "⏳ Loading" : t.every((e => "success" === e)) ? "✅ All Good" : "📊 Mixed Status" } recordClick(e) { const t = this.clickLoggers.get(e); t && t.recordClick() } _getDirectiveColor(e) { return { "@for": "#ff9800", "@fetch": "#4caf50", "@model": "#2196f3", "@if": "#9c27b0", "@show": "#9c27b0", "@hide": "#9c27b0", "@click": "#f44336", "@component": "#00bcd4", "@input": "#e91e63", "@focus": "#3f51b5", "@blur": "#607d8b", "@change": "#795548", generic: "#666666" }[e] || "#666666" } _generateIntelligentLogHTML(e) { const t = e.timestamp.toLocaleTimeString(); if ("multi-directive" === e.type) { let i = `\n          <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">\n            <span style="color: #66ccff; font-weight: bold;">🎯 &lt;${e.tag}&gt; (${e.directives.length} directives)</span>\n            <span style="color: #999; font-size: 10px;">${t}</span>\n          </div>\n          <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">\n            <span style="color: #ffcc66; font-size: 10px;">⏱️ ${e.executionTime}</span>\n            <span style="color: ${this._getStatusColor(e.overallStatus)}; font-size: 10px; font-weight: bold;">${e.overallStatus}</span>\n          </div>\n        `; return e.directives.forEach(((e, t) => { const s = this._getDirectiveColor(e.type), r = this._getStatusColor(e.status); i += `\n            <div style="border-left: 3px solid ${s}; margin: 6px 0; padding: 6px 8px; background: rgba(255,255,255,0.03); border-radius: 3px;">\n              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">\n                <span style="color: ${s}; font-weight: bold; font-size: 11px;">\n                  ${e.isSubDirective ? "📎" : "📋"} ${e.type}\n                </span>\n                <span style="color: ${r}; font-size: 9px;">${this._getStatusIcon(e.status)}</span>\n              </div>\n              ${this._generateCompactDirectiveHTML(e.type, e.data)}\n            </div>\n          ` })), i } return '<div style="color: #cccccc;">Generic log entry</div>' } _getStatusColor(e) { if (!e) return "#cccccc"; if ("string" == typeof e) { if (e.includes("error") || e.includes("❌")) return "#ff6b6b"; if (e.includes("loading") || e.includes("⏳")) return "#ffa726"; if (e.includes("success") || e.includes("✅")) return "#66bb6a" } return "#cccccc" } _getStatusIcon(e) { return e ? "error" === e ? "❌" : "loading" === e ? "⏳" : "success" === e ? "✅" : "unknown" === e ? "❓" : "📊" : "📊" } _generateCompactDirectiveHTML(e, t) { if (!t) return '<div style="color: #999;">No data available</div>'; let i = ""; try { switch (e.split(":")[0]) { case "@for": i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Array: <strong>${t.arrayVariable || "unknown"}</strong> (${t.length || 0} items)<br>\n                Status: ${t.status || "unknown"}\n              </div>\n            `; break; case "@fetch": const e = t.url || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                URL: <strong>${e.slice(0, 40)}${e.length > 40 ? "..." : ""}</strong><br>\n                Status: ${t.status || "unknown"} | Size: ${t.responseSize || "N/A"}\n              </div>\n            `; break; case "@model": const s = t.currentValue, r = "string" == typeof s ? `"${s.slice(0, 20)}${s.length > 20 ? "..." : ""}"` : JSON.stringify(s); i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Variable: <strong>${t.variable || "unknown"}</strong><br>\n                Value: ${r} | ${t.validation?.status || "No validation"}\n              </div>\n            `; break; case "@if": case "@show": case "@hide": const n = t.condition || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Condition: <strong>${n.slice(0, 30)}${n.length > 30 ? "..." : ""}</strong><br>\n                Result: ${t.result} → ${t.isVisible ? "Visible" : "Hidden"}\n              </div>\n            `; break; case "@click": const a = t.action || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Action: <strong>${a.slice(0, 30)}${a.length > 30 ? "..." : ""}</strong><br>\n                Clicks: ${t.clickCount || 0} | Last: ${t.lastClick || "Never"}\n              </div>\n            `; break; case "@component": const o = t.source || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Source: <strong>${o.slice(0, 30)}${o.length > 30 ? "..." : ""}</strong><br>\n                Status: ${t.status || "unknown"} | Cached: ${t.cached ? "Yes" : "No"}\n              </div>\n            `; break; case "@input": const l = t.action || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Action: <strong>${l.slice(0, 30)}${l.length > 30 ? "..." : ""}</strong><br>\n                Inputs: ${t.inputCount || 0} | Last: ${t.lastInput || "Never"}\n              </div>\n            `; break; case "@focus": const c = t.action || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Action: <strong>${c.slice(0, 30)}${c.length > 30 ? "..." : ""}</strong><br>\n                Focus events: ${t.focusCount || 0} | Last: ${t.lastFocus || "Never"}\n              </div>\n            `; break; case "@blur": const d = t.action || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Action: <strong>${d.slice(0, 30)}${d.length > 30 ? "..." : ""}</strong><br>\n                Blur events: ${t.blurCount || 0} | Last: ${t.lastBlur || "Never"}\n              </div>\n            `; break; case "@change": const h = t.action || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Action: <strong>${h.slice(0, 30)}${h.length > 30 ? "..." : ""}</strong><br>\n                Change events: ${t.changeCount || 0} | Last: ${t.lastChange || "Never"}\n              </div>\n            `; break; default: const u = t.expression || ""; i = `\n              <div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n                Expression: <strong>${u.slice(0, 40)}${u.length > 40 ? "..." : ""}</strong><br>\n                Status: ${t.status || "unknown"}\n              </div>\n            ` }t.error && (i += `<div style="color: #ff6b6b; font-size: 9px; margin-top: 2px;">💥 ${t.error}</div>`) } catch (e) { i = `<div style="color: #ff6b6b; font-size: 9px;">Error rendering directive data: ${e.message}</div>` } return i } } class we { showAllErrors(e = document.body) { if (!this.errorBus) return; const t = e.querySelector(".ayisha-error-list"); t && t.remove(); const i = this.errorBus.getAll(); if (!i.length) return; const s = document.createElement("div"); s.className = "ayisha-error-list", s.style.cssText = "\n      background: #fff3f3;\n      color: #c00;\n      border: 1px solid #c00;\n      border-radius: 8px;\n      padding: 16px;\n      margin: 16px 0;\n      font-family: 'JetBrains Mono', 'Courier New', monospace;\n      font-size: 13px;\n      max-width: 600px;\n      box-shadow: 0 2px 8px rgba(200,0,0,0.08);\n    ", s.innerHTML = `<div style='font-weight:bold; color:#900; margin-bottom:8px;'>❌ Ayisha Error Log (${i.length})</div>`, i.forEach(((e, t) => { const i = document.createElement("div"); i.style.cssText = "margin-bottom:10px; padding:8px; border-bottom:1px solid #fdd;", i.innerHTML = `\n        <div style='font-weight:bold;'>${t + 1}. ${e.error?.message || e.error || "Unknown error"}</div>\n        <div style='color:#333; font-size:12px;'>${e.context && e.context.expr ? `<b>Expr:</b> <code>${e.context.expr}</code><br>` : ""}\n          ${e.context && e.context.type ? `<b>Type:</b> ${e.context.type}<br>` : ""}\n          <b>Time:</b> ${new Date(e.timestamp).toLocaleString()}\n        </div>\n      `, s.appendChild(i) })), e.appendChild(s) } isBot() { const e = navigator.userAgent.toLowerCase(); return /bot|crawler|spider|googlebot|bingbot|facebookexternalhit|twitterbot/i.test(e) } renderForSEO() { this.processAllDirectivesSync(), this.loadAllComponentsSync(), this.executeAllFetchSync(), this.generateMetaTags() } processAllDirectivesSync() { Object.keys(ae).forEach((e => { document.querySelectorAll(`[\\${e}]`).forEach((t => { const i = new (0, ae[e])(this.evaluator, this.bindingManager, this.errorHandler), s = { _el: t, directives: { [e]: t.getAttribute(e) } }; i.apply(s, this.state, this.state, t) })) })) } loadAllComponentsSync() { document.querySelectorAll("[data-component]").forEach((e => { const t = e.getAttribute("data-component"); this.componentManager && this.componentManager.getComponent(t) && (e.innerHTML = this.componentManager.getComponent(t)) })) } executeAllFetchSync() { const e = document.querySelectorAll("[\\@fetch]"), t = []; if (e.forEach((e => { const i = e.getAttribute("@fetch"); let s = i, r = "result"; const n = i.match(/(.+) as (\w+)/); n && (s = n[1].trim(), r = n[2].trim()); try { s = this.evaluator.evalExpr(s, this.state) } catch { } s && t.push(fetch(s).then((e => e.json())).then((e => { this.state[r] = e })).catch((() => { this.state[r] = null }))) })), t.length > 0) { const e = Date.now(); let i = !1; for (Promise.all(t).then((() => { i = !0 })); !i && Date.now() - e < 2e3;); } } generateMetaTags() { const e = document.querySelector("h1"); e && !document.title && (document.title = e.textContent); const t = document.body.textContent.slice(0, 160); if (!document.querySelector('meta[name="description"]')) { const e = document.createElement("meta"); e.name = "description", e.content = t, document.head.appendChild(e) } } renderToString(e, t = {}) { if (!this.isServerSide() && !this.options.ssr) throw new Error("renderToString can only be called in SSR mode"); this._isSSRMode = !0, this.state = { ...this.state, ...t }, this._preInitializeEssentialVariables(), this._runInitBlocks(), this._vdom = this._parseTemplateForSSR(e); const i = this._renderVNodeToString(this._vdom, this.state); return this._hydrationData = { state: this._serializeState(this.state), version: we.version }, { html: i, state: this._hydrationData.state, hydrationScript: this._generateHydrationScript() } } _parseTemplateForSSR(e) { const t = [], i = { tag: "fragment", children: [], directives: {} }; let s = i; const r = /<(\/?[a-zA-Z][a-zA-Z0-9]*)((?:\s+[^>]*)?)>/g; let n, a = 0; for (; null !== (n = r.exec(e));) { const i = e.slice(a, n.index).trim(); i && s.children.push({ type: "text", text: i }); const o = n[1], l = n[2]; if (o.startsWith("/")) t.length > 0 && (s = t.pop()); else { const e = { tag: o.toLowerCase(), children: [], directives: {}, attrs: {} }; if (l) { const t = /([a-zA-Z@][a-zA-Z0-9_-]*)\s*=\s*"([^"]*)"/g; let i; for (; null !== (i = t.exec(l));) { const t = i[1], s = i[2]; t.startsWith("@") ? e.directives[t] = s : e.attrs[t] = s } const s = /([a-zA-Z@][a-zA-Z0-9_-]*)\s*=\s*'([^']*)'/g; let r; for (; null !== (r = s.exec(l));) { const t = r[1], i = r[2]; t.startsWith("@") ? e.directives[t] = i : e.attrs[t] = i } const n = /([a-zA-Z@][a-zA-Z0-9_-]*)\s*=\s*([^"'\s>]+)/g; let a; for (; null !== (a = n.exec(l));) { const t = a[1], i = a[2]; t.startsWith("@") ? e.directives[t] = i : e.attrs[t] = i } } s.children.push(e);["img", "br", "hr", "input", "meta", "link"].includes(o.toLowerCase()) || l.includes("/") || (t.push(s), s = e) } a = r.lastIndex } const o = e.slice(a).trim(); return o && s.children.push({ type: "text", text: o }), i } _createVirtualElement(e) { const t = { tagName: e.toUpperCase(), innerHTML: "", textContent: "", setAttribute: function (e, t) { this.attributes = this.attributes || {}, this.attributes[e] = t }, getAttribute: function (e) { return this.attributes?.[e] || null }, hasAttribute: function (e) { return this.attributes && e in this.attributes }, childNodes: [], children: [], nodeType: 1, attributes: {}, appendChild: function (e) { this.childNodes.push(e), 1 === e.nodeType && this.children.push(e) }, querySelector: function (e) { return null }, querySelectorAll: function (e) { return [] } }; return Object.defineProperty(t, "innerHTML", { get: function () { return this._innerHTML || "" }, set: function (e) { this._innerHTML = e, this.childNodes = [], this.children = [], e && this._parseHTML(e) } }), t._parseHTML = function (e) { if (e.trim()) { const t = { nodeType: 3, textContent: e, nodeValue: e }; this.childNodes.push(t) } }, t } _renderVNodeToString(e, t) { if (!e) return ""; if ("text" === e.type) return this._escapeHtml(this.evaluator.evalText(e.text, t)); if ("fragment" === e.tag) return e.children.map((e => this._renderVNodeToString(e, t))).join(""); if (e.directives && e.directives["@if"] && !this.evaluator.evalExpr(e.directives["@if"], t)) return ""; if (e.directives && e.directives["@show"] && !this.evaluator.evalExpr(e.directives["@show"], t)) return ""; if (e.directives && e.directives["@hide"] && this.evaluator.evalExpr(e.directives["@hide"], t)) return ""; if (e.directives && e.directives["@for"]) return this._handleForDirectiveSSR(e, t); if (e.directives && e.directives["@switch"]) return this._handleSwitchDirectiveSSR(e, t); if ("component" === e.tag) return this._handleComponentDirectiveSSR(e, t); let i = `<${e.tag}`; if (Object.entries(e.attrs || {}).forEach((([e, s]) => { const r = this.evaluator.evalAttrValue ? this.evaluator.evalAttrValue(s, t) : s; i += ` ${e}="${this._escapeHtml(r)}"` })), e.directives && Object.keys(e.directives).length > 0 && (i += ' data-ayisha-hydrate="true"', i += ` data-ayisha-directives="${this._escapeHtml(JSON.stringify(e.directives))}"`), i += ">", e.directives && e.directives["@text"]) { const s = this.evaluator.evalExpr(e.directives["@text"], t); i += this._escapeHtml(String(s || "")) } else e.children && e.children.forEach((e => { i += this._renderVNodeToString(e, t) })); return i += `</${e.tag}>`, i } _handleForDirectiveSSR(e, t) { let i = e.directives["@for"].match(/(\w+),\s*(\w+) in (.+)/); if (i) { const [, s, r, n] = i; let a = this.evaluator.evalExpr(n, t) || []; return "object" != typeof a || Array.isArray(a) || (a = Object.values(a)), a.map(((i, n) => { const a = JSON.parse(JSON.stringify(e)); delete a.directives["@for"]; const o = { ...t, [r]: i, [s]: n }; return this._renderVNodeToString(a, o) })).join("") } if (i = e.directives["@for"].match(/(\w+) in (.+)/), i) { const [, s, r] = i; let n = this.evaluator.evalExpr(r, t) || []; return "object" != typeof n || Array.isArray(n) || (n = Object.values(n)), n.map(((i, r) => { const n = JSON.parse(JSON.stringify(e)); delete n.directives["@for"]; const a = { ...t, [s]: i, $index: r }; return this._renderVNodeToString(n, a) })).join("") } return "" } _handleSwitchDirectiveSSR(e, t) { const i = this.evaluator.evalExpr(e.directives["@switch"], t); for (const s of e.children || []) if (s.directives) { if (null != s.directives["@case"]) { let e = s.directives["@case"]; if (/^['"].*['"]$/.test(e) && (e = e.slice(1, -1)), String(e) === String(i)) return this._renderVNodeToString(s, t) } if (null != s.directives["@default"]) return this._renderVNodeToString(s, t) } return "" } _handleComponentDirectiveSSR(e, t) { const i = e.directives["@src"]; if (i && this.componentManager?.getCachedComponent(i)) { return this.componentManager.getCachedComponent(i) } return `\x3c!-- Component: ${i || "unknown"} --\x3e` } _escapeHtml(e) { const t = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }; return String(e).replace(/[&<>"']/g, (e => t[e])) } _serializeState(e) { const t = {}; return Object.keys(e).forEach((i => { if ("function" != typeof e[i] && "_ayishaInstance" !== i) try { JSON.stringify(e[i]), t[i] = e[i] } catch (e) { } })), t } _generateHydrationScript() { return `\n<script>\nwindow.__AYISHA_HYDRATION_DATA__ = ${JSON.stringify(this._hydrationData)};\n<\/script>` } static version = "1.0.3"; isServerSide() { return "undefined" == typeof window || "undefined" == typeof document || "undefined" != typeof global } isNodeJS() { return "undefined" != typeof process && process.versions && process.versions.node } constructor(t = document.body, h = {}) { if (this.options = { ssr: !1, hydration: !1, initialState: {}, ...h }, this.errorBus = new e, this.errorBus.onError((() => { setTimeout((() => this.showAllErrors()), 0) })), this.root = t, this.state = { ...this.options.initialState }, this._initBlocks = [], this._vdom = null, this._isRendering = !1, this._processedSetDirectives = new Set, this._componentRenderTimeout = null, this._setNodes = new WeakSet, this._isSSRMode = this.options.ssr || this.isServerSide(), this._isHydrationMode = this.options.hydration, this._ssrOutput = "", this._hydrationData = {}, this.evaluator = new i(this.state), this.parser = new s(this._initBlocks), this.componentManager = new r, this.reactivitySystem = new n(this.state, (() => this.render())), this.router = new a(this.state, (() => this.render())), this.fetchManager = new o(this.evaluator), this.helpSystem = new l, this.errorHandler = new c(this.errorBus), this.bindingManager = new d(this.evaluator, (() => this.render())), this.centralLogger = new be, this.centralLogger.initializeLoggers(this.evaluator, this.fetchManager, this.componentManager), this.directiveManager = new oe(this.evaluator, this.bindingManager, this.errorHandler, this.fetchManager), !("_currentPage" in this.state) || !this.state._currentPage) { let e = null, t = []; if ("undefined" != typeof document) try { t = document.querySelectorAll("[@page]") } catch (e) { try { t = document.querySelectorAll("[@page]") } catch (e) { t = [] } } t.length > 0 && (e = t[0].getAttribute("@page")), this.state._currentPage = e || "home" } this.isBot && "function" == typeof this.isBot && this.isBot() && this.renderForSEO(), "undefined" != typeof window && (window.ayisha = this) } component(e, t) { this.componentManager.component(e, t) } addWatcher(e, t) { this.reactivitySystem.addWatcher(e, t) } directiveHelp(e) { return this.helpSystem.getHelp(e) } parse(e) { return this.parser.parse(e) } _runInitBlocks() { if (this._isRendering) return; this._initBlocks.forEach((e => { if (!e || !e.trim()) return; let t = e.trim().replace(/[\u200B-\u200D\uFEFF]/g, "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/\n\s*\n/g, "\n").replace(/\n\s+/g, "\n").trim(); const i = t.split("\n"); t = i.map((e => { const t = e.trim(); if (!t || t.startsWith("function") || t.includes("function(") || t.includes("=>") || /^(if|else|for|while|switch|case|default|try|catch|finally|return|var|let|const)\b/.test(t)) return e; const i = t.match(/^([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(.+)$/); if (i && !t.includes("state.") && !t.includes("this.") && !t.includes("window.") && !t.includes("console.") && !t.includes("localStorage.") && !t.includes("sessionStorage.")) { const [, t, s] = i; if (!["JSON", "Object", "Array", "String", "Number", "Boolean", "Date", "Math", "RegExp"].includes(t)) return e.replace(i[0], `state.${t} = ${s}`) } return e })).join("\n"); try { new Function("state", t)(this.state) } catch (e) { } }));["JSON", "Object", "Array", "String", "Number", "Boolean", "Date", "Math", "RegExp", "console", "window", "document", "setTimeout", "setInterval", "fetch", "localStorage", "sessionStorage", "history", "location", "navigator", "undefined", "null", "true", "false"].forEach((e => { e in this.state && delete this.state[e] })); Object.keys(this.state).forEach((e => { /[+\-*\/=<>!&|(){}[\].,\s]|=>|==|!=|<=|>=|\|\||&&/.test(e) && delete this.state[e] }));["_validate", "_currentPage", "_version", "_locale"].forEach((e => { e in this.state || ("_validate" === e ? this.state[e] = {} : "_currentPage" === e ? this.state[e] = "" : "_version" === e ? this.state[e] = we.version : "_locale" === e && (this.state[e] = "undefined" != typeof navigator && (navigator.language || navigator.userLanguage) || "en")) })), "_ayishaInstance" in this.state && delete this.state._ayishaInstance; Object.keys(this.state).filter((e => e.includes("=") || e.includes("<") || e.includes(">") || e.includes("!") || e.includes("&") || e.includes("|") || e.includes("'") || e.includes('"') || e.includes("(") || e.includes(")") || e.includes(" "))).forEach((e => { delete this.state[e] })) } _preInitializeEssentialVariables() { this.state._validate || (this.state._validate = {}), this.state._currentPage || (this.state._currentPage = ""), this.state._version || (this.state._version = we.version), this.state._locale || (this.state._locale = "undefined" != typeof navigator && (navigator.language || navigator.userLanguage) || "en"), "_ayishaInstance" in this.state && delete this.state._ayishaInstance; const e = () => { var e; "undefined" != typeof window ? (this.state._currentBreakpoint = (e = window.innerWidth) < 576 ? "xs" : e < 768 ? "sm" : e < 992 ? "md" : e < 1200 ? "lg" : e < 1400 ? "xl" : "xxl", this.state._screenSize = window.innerWidth) : (this.state._currentBreakpoint = "lg", this.state._screenSize = 1200) }; e(), this._breakpointListenerAdded || "undefined" == typeof window || (window.addEventListener("resize", e), this._breakpointListenerAdded = !0) } _makeReactive() { this.state = this.reactivitySystem.makeReactive(), this.evaluator.state = this.state, this.fetchManager.evaluator.state = this.state } _setupRouting() { this.router.setupRouting() } _findFirstPageDirective(e) { if (!e) return null; if (e.directives && e.directives["@page"]) return e; if (e.children && e.children.length) for (const t of e.children) { const e = this._findFirstPageDirective(t); if (e) return e } return null } async preloadComponents() { const e = [], t = new Set; if (this.root.querySelectorAll("component").forEach((i => { let s = null; if (i.hasAttribute("src")) s = i.getAttribute("src"); else if (i.hasAttribute("@src")) { const e = i.getAttribute("@src"); if (/^['\"].*['\"]$/.test(e)) s = e.slice(1, -1); else try { s = this.evaluator.evalExpr(e) } catch (t) { (e.includes(".html") || e.startsWith("./")) && (s = e) } } !s || t.has(s) || this.componentManager.getCachedComponent(s) || (t.add(s), e.push(this.componentManager.loadExternalComponent(s))) })), e.length > 0) try { await Promise.allSettled(e) } catch (e) { } } render() { if (this._isRendering) return; this._isRendering = !0, "_ayishaInstance" in this.state && delete this.state._ayishaInstance; const e = Object.keys(this.state).filter((e => e.includes("=") || e.includes("<") || e.includes(">") || e.includes("!") || e.includes("&") || e.includes("|") || e.includes("'") || e.includes('"') || e.includes("(") || e.includes(")") || e.includes(" ") || e.includes("+") || e.includes("-") || e.includes("*") || e.includes("/") || e.includes("%") || e.includes("[") || e.includes("]") || e.includes("{") || e.includes("}") || e.includes("?") || e.includes(":") || e.includes(";") || e.includes(",") || !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(e))); e.length > 0 && e.forEach((e => { delete this.state[e] })); const t = window.scrollX, i = window.scrollY, s = document.activeElement; let r = null; if (s && ("INPUT" === s.tagName || "TEXTAREA" === s.tagName)) { const e = []; let t = s; for (; t && t !== this.root;) { const i = t.parentNode; e.unshift([...i.childNodes].indexOf(t)), t = i } r = { path: e, start: s.selectionStart, end: s.selectionEnd, type: s.type } } this.bindingManager.clearBindings(); const n = this._renderVNode(this._vdom, this.state); if (this.root === document.body ? (document.body.innerHTML = "", n && (void 0 === n.tagName && n.childNodes ? Array.from(n.childNodes).forEach((e => document.body.appendChild(e))) : (DocumentFragment, document.body.appendChild(n)))) : (this.root.innerHTML = "", n && (void 0 === n.tagName && n.childNodes ? Array.from(n.childNodes).forEach((e => this.root.appendChild(e))) : (DocumentFragment, this.root.appendChild(n)))), r) { let e = this.root; for (const t of r.path) { if (!e || !e.childNodes || !e.childNodes[t]) { e = void 0; break } e = e.childNodes[t] } if (e && ("INPUT" === e.tagName || "TEXTAREA" === e.tagName)) { e.focus(); try { ("INPUT" === e.tagName && "number" == typeof e.selectionStart && "function" == typeof e.setSelectionRange && "number" !== e.type || "TEXTAREA" === e.tagName) && e.setSelectionRange(r.start, r.end) } catch (e) { } } } this._addLogIndicators(), window.scrollTo(t, i), this.bindingManager.updateBindings(), this._whenDirectiveWatchers && this._whenDirectiveWatchers.forEach((e => { try { e() } catch { } })), this._isRendering = !1 } _addLogIndicators() { this.root.querySelectorAll('[data-ayisha-log="true"]').forEach((e => { const t = e.nextElementSibling; t && t.classList.contains("ayisha-log-display") && t.remove(); try { const t = JSON.parse(e.getAttribute("data-ayisha-log-info") || "{}"), i = document.createElement("div"); i.className = "ayisha-log-display", i.style.cssText = "\n            background: rgba(0, 20, 40, 0.95) !important;\n            color: #fff !important;\n            padding: 8px 12px !important;\n            margin: 4px 0 !important;\n            border-radius: 6px !important;\n            font-family: 'JetBrains Mono', 'Courier New', monospace !important;\n            font-size: 11px !important;\n            border-left: 4px solid #0066cc !important;\n            box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;\n            max-width: 400px !important;\n            overflow-x: auto !important;\n            line-height: 1.4 !important;\n          "; const s = this._generateInlineLogContent(e, t); i.innerHTML = s, e.parentNode && e.parentNode.insertBefore(i, e.nextSibling) } catch (e) { } })); this.root.querySelectorAll("[data-ayisha-log-error]").forEach((e => { const t = e.getAttribute("data-ayisha-log-error"), i = document.createElement("div"); i.className = "ayisha-log-error-display", i.style.cssText = "\n          background: rgba(255, 0, 0, 0.9) !important;\n          color: white !important;\n          padding: 8px 12px !important;\n          margin: 4px 0 !important;\n          border-radius: 6px !important;\n          font-family: monospace !important;\n          font-size: 11px !important;\n          font-weight: bold !important;\n          display: block !important;\n        ", i.innerHTML = `❌ Log Error: ${t}`, e.parentNode && e.parentNode.insertBefore(i, e.nextSibling) })) } _generateInlineLogContent(e, t) { const i = { tag: t.tag || e.tagName.toLowerCase(), directives: t.directives || {}, subDirectives: t.subDirectives || {} }, s = {}; let r = `<div style="color: #66ccff; font-weight: bold; margin-bottom: 6px;">📊 &lt;${i.tag}&gt;</div>`, n = !1, a = 0; if (Object.keys(i.directives).forEach((e => { if ("@log" !== e) if (a++, this.centralLogger.loggers[e]) { n = !0; try { const t = this.centralLogger.loggers[e].log(i, s, this.state); r += this._formatDirectiveLog(e, t.data) } catch (t) { r += `<div style="color: #ff6b6b; margin: 2px 0;">\n              <span style="color: #ff9999;">${e}</span>: \n              <span style="color: #ffcccc;">❌ ${t.message}</span>\n            </div>` } } else r += `<div style="color: #999; margin: 2px 0;">\n            <span style="color: #ccc;">${e}</span>: \n            <span style="color: #aaa;">${this._truncateValue(i.directives[e])}</span>\n            <span style="color: #777; font-size: 10px;"> [untracked]</span>\n          </div>` })), Object.entries(i.subDirectives || {}).forEach((([e, t]) => { Object.keys(t).forEach((o => { a++; const l = `${e}:${o}`; if (this.centralLogger.loggers[e]) { n = !0; try { const t = this.centralLogger.loggers[e].log(i, s, this.state); r += this._formatDirectiveLog(l, t.data, !0) } catch (e) { r += `<div style="color: #ff6b6b; margin: 2px 0;">\n                <span style="color: #ff9999;">${l}</span>: \n                <span style="color: #ffcccc;">❌ ${e.message}</span>\n              </div>` } } else r += `<div style="color: #999; margin: 2px 0;">\n              <span style="color: #ccc;">${l}</span>: \n              <span style="color: #aaa;">${this._truncateValue(t[o])}</span>\n              <span style="color: #777; font-size: 10px;"> [untracked]</span>\n            </div>` })) })), 0 === a ? r += '<div style="color: #ff9966; font-style: italic; margin: 4px 0;">\n          ⚠️ Element has @log but no other directives\n        </div>' : n || (r += `<div style="color: #ffa726; font-style: italic; margin: 4px 0;">\n          Found ${a} directive(s) but none are tracked by loggers\n        </div>`), t.elementInfo) { const e = t.elementInfo; (e.className || e.id) && (r += `<div style="color: #666; font-size: 10px; margin-top: 4px; padding-top: 2px; border-top: 1px solid #333;">\n            ${e.className ? `Class: ${e.className}` : ""}${e.className && e.id ? " | " : ""}${e.id ? `ID: ${e.id}` : ""}\n          </div>`) } return r += `<div style="color: #666; font-size: 10px; margin-top: 4px; border-top: 1px solid #333; padding-top: 2px;">\n        ${(new Date).toLocaleTimeString()}\n      </div>`, r } _formatDirectiveLog(e, t, i = !1) { const s = i ? "📎" : "📋"; let r = '<div style="margin: 4px 0; padding: 4px; background: rgba(255,255,255,0.03); border-radius: 3px;">'; if (r += `<div style="color: ${this._getDirectiveColor(e.split(":")[0])}; font-weight: bold; font-size: 11px; margin-bottom: 2px;">\n        ${s} ${e}\n      </div>`, !t) return r += '<div style="color: #999;">No data available</div>', r += "</div>", r; switch (e.split(":")[0]) { case "@for": r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Array: <strong style="color: #ffcc66;">${t.arrayVariable || "unknown"}</strong> (${t.length || 0} items)<br>\n            Status: <span style="color: ${this._getStatusColor(t.status)};">${t.status || "unknown"}</span><br>\n            Item var: <span style="color: #66ccff;">${t.itemVariable || "unknown"}</span>\n            ${t.indexVariable ? `, Index var: <span style="color: #66ccff;">${t.indexVariable}</span>` : ""}\n          </div>`; break; case "@fetch": const e = t.url || ""; r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            URL: <strong style="color: #66ff66;">${e.slice(0, 35)}${e.length > 35 ? "..." : ""}</strong><br>\n            Result var: <span style="color: #ffcc66;">${t.resultVariable || "result"}</span><br>\n            Status: <span style="color: ${this._getStatusColor(t.status)};">${t.status || "unknown"}</span><br>\n            Size: <span style="color: #ccc;">${t.responseSize || "N/A"}</span>\n          </div>`; break; case "@model": const i = t.currentValue, s = "string" == typeof i ? `"${i.slice(0, 20)}${i.length > 20 ? "..." : ""}"` : JSON.stringify(i); r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Variable: <strong style="color: #66ccff;">${t.variable || "unknown"}</strong><br>\n            Value: <span style="color: #ffcc66;">${s}</span> \n            <span style="color: #999;">(${t.valueType})</span><br>\n            ${t.validation ? `Validation: <span style="color: ${this._getStatusColor(t.validation.status)};">${t.validation.status}</span>` : "No validation"}\n          </div>`; break; case "@if": case "@show": case "@hide": const n = t.condition || ""; r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Condition: <strong style="color: #ffcc66;">${n.slice(0, 25)}${n.length > 25 ? "..." : ""}</strong><br>\n            Result: <span style="color: #66ccff;">${t.result}</span> → \n            <span style="color: ${t.isVisible ? "#66bb6a" : "#ff6b6b"};">${t.isVisible ? "Visible" : "Hidden"}</span>\n          </div>`; break; case "@click": const a = t.action || ""; r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Action: <strong style="color: #ffcc66;">${a.slice(0, 25)}${a.length > 25 ? "..." : ""}</strong><br>\n            Clicks: <span style="color: #66ccff;">${t.clickCount || 0}</span><br>\n            Last: <span style="color: #999;">${t.lastClick || "Never"}</span>\n          </div>`; break; case "@component": const o = t.source || ""; r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Source: <strong style="color: #66ccff;">${o.slice(0, 30)}${o.length > 30 ? "..." : ""}</strong><br>\n            Status: <span style="color: ${this._getStatusColor(t.status)};">${t.status || "unknown"}</span><br>\n            Cached: <span style="color: ${t.cached ? "#66bb6a" : "#ff9800"};">${t.cached ? "Yes" : "No"}</span>\n          </div>`; break; case "@input": const l = t.action || ""; r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Action: <strong style="color: #ffcc66;">${l.slice(0, 25)}${l.length > 25 ? "..." : ""}</strong><br>\n            Inputs: <span style="color: #66ccff;">${t.inputCount || 0}</span><br>\n            Last: <span style="color: #999;">${t.lastInput || "Never"}</span>\n          </div>`; break; case "@focus": const c = t.action || ""; r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Action: <strong style="color: #ffcc66;">${c.slice(0, 25)}${c.length > 25 ? "..." : ""}</strong><br>\n            Focus events: <span style="color: #66ccff;">${t.focusCount || 0}</span><br>\n            Last: <span style="color: #999;">${t.lastFocus || "Never"}</span>\n          </div>`; break; case "@blur": const d = t.action || ""; r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Action: <strong style="color: #ffcc66;">${d.slice(0, 25)}${d.length > 25 ? "..." : ""}</strong><br>\n            Blur events: <span style="color: #66ccff;">${t.blurCount || 0}</span><br>\n            Last: <span style="color: #999;">${t.lastBlur || "Never"}</span>\n          </div>`; break; case "@change": const h = t.action || ""; r += `<div style="color: #cccccc; font-size: 10px; line-height: 1.3;">\n            Action: <strong style="color: #ffcc66;">${h.slice(0, 25)}${h.length > 25 ? "..." : ""}</strong><br>\n            Change events: <span style="color: #66ccff;">${t.changeCount || 0}</span><br>\n            Last: <span style="color: #999;">${t.lastChange || "Never"}</span>\n          </div>`; break; default: r += `<div style="color: #cccccc; font-size: 10px;">\n            Expression: <span style="color: #ffcc66;">${t.expression || "N/A"}</span><br>\n            Status: <span style="color: #999;">${t.status || "unknown"}</span>\n          </div>` }return t.error && (r += `<div style="color: #ff6b6b; font-size: 9px; margin-top: 2px; padding: 2px; background: rgba(255,0,0,0.1); border-radius: 2px;">\n          💥 ${t.error}\n        </div>`), r += "</div>", r } _getDirectiveColor(e) { return { "@for": "#ff9800", "@fetch": "#4caf50", "@model": "#2196f3", "@if": "#9c27b0", "@show": "#9c27b0", "@hide": "#9c27b0", "@click": "#f44336", "@component": "#00bcd4", generic: "#666666" }[e] || "#666666" } _getStatusColor(e) { if (!e) return "#cccccc"; if ("string" == typeof e) { if (e.includes("error") || e.includes("❌")) return "#ff6b6b"; if (e.includes("loading") || e.includes("⏳")) return "#ffa726"; if (e.includes("success") || e.includes("✅")) return "#66bb6a" } return "#cccccc" } _getStatusIcon(e) { return e ? "error" === e ? "❌" : "loading" === e ? "⏳" : "success" === e ? "✅" : "unknown" === e ? "❓" : "📊" : "📊" } _truncateValue(e, t = 30) { return "string" != typeof e && (e = String(e)), e.length > t ? e.slice(0, t) + "..." : e } _renderVNode(e, i) { if (!e) return null; let s = null; if (e && (e.directives?.["@then"] || e.directives?.["@finally"]) && (s = new t(e, i, this), e.directives["@then"] && s.addThen(e.directives["@then"]), e.directives["@finally"] && s.addFinally(e.directives["@finally"])), e.directives && e.directives["@set"] && !e._setProcessed) { let t = e.directives["@set"]; t = Array.isArray(t) ? t.flat().filter(Boolean) : "string" == typeof t ? t.split(/;;|\n/).map((e => e.trim())).filter(Boolean) : [t], t.forEach((t => { try { const e = /([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=([^=].*)/g; let s; for (; null !== (s = e.exec(t));) { const e = s[1]; e in this.state && void 0 !== this.state[e] || (this.state[e] = this.evaluator.evalExpr(s[2], i)) } } catch (t) { e._setErrors || (e._setErrors = []), e._setErrors.push(t.message) } })), e._setProcessed = !0, delete e.directives["@set"] } Object.entries(e.directives || {}).forEach((([e, t]) => { !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(t.trim()) || t.includes("=") || t.includes("<") || t.includes(">") || t.includes("!") || t.includes("&") || t.includes("|") || t.includes("'") || t.includes('"') || t.includes("(") || t.includes(")") || ("@model" === e ? this.evaluator.ensureVarInState(t, !0) : this.evaluator.ensureVarInState(t)) })), Object.values(e.subDirectives || {}).forEach((e => Object.values(e).forEach((e => { !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(e.trim()) || e.includes("=") || e.includes("<") || e.includes(">") || e.includes("!") || e.includes("&") || e.includes("|") || e.includes("'") || e.includes('"') || e.includes("(") || e.includes(")") || this.evaluator.ensureVarInState(e) })))); let r = null, n = null, a = null; if (e && e.directives) for (const t of Object.keys(e.directives)) if (("@src" !== t || "component" !== e.tag) && "@attr" !== t && "@then" !== t && "@finally" !== t && !this.helpSystem.isValidDirective(t)) { r = t; break } if (!r && e && e.subDirectives) for (const [t, i] of Object.entries(e.subDirectives)) { for (const e of Object.keys(i)) { const i = `${t}:${e}`; if (!this.helpSystem.isValidDirective(i)) { n = t, a = e; break } } if (n) break } if (r || n) { let e = ""; if (r) e = `Error: Unknown directive <b>${r}</b>.`, e += "<br>" + this.directiveHelp(r); else { const t = `${n}:${a}`; e = `Error: Unknown sub-directive <b>${t}</b>.`, e += "<br>" + this.directiveHelp(t) } return this.errorHandler.createErrorElement(e) } if ("text" === e.type) return document.createTextNode(this.evaluator.evalText(e.text, i)); if ("fragment" === e.tag) { const t = document.createDocumentFragment(); return e.children.forEach((e => { const s = this._renderVNode(e, i); s && t.appendChild(s) })), t } if (e.directives["@if"] && !this.evaluator.evalExpr(e.directives["@if"], i)) return null; if (e.directives["@show"] && !this.evaluator.evalExpr(e.directives["@show"], i)) return null; if (e.directives["@hide"] && this.evaluator.evalExpr(e.directives["@hide"], i)) return null; if (e.directives["@for"]) { const t = this.directiveManager.directives.get("@for"), r = { ...this.state, _ayishaInstance: this }; return t.apply(e, i, r, null, s) } if (e.directives["@switch"]) { const t = this.directiveManager.directives.get("@switch"), r = { ...this.state, _ayishaInstance: this }; return t.apply(e, i, r, null, s) } if (e.directives["@source"]) return this._handleFunctionalDirectives(e, i, s); if ("component" === e.tag) { if (e.directives["@page"]) { const t = e.directives["@page"], r = this.state._currentPage || this.state.currentPage; if (String(t) !== String(r)) return this._handleComponentDirective(e, i, s), null } return this._handleComponentDirective(e, i, s) } if ("no" === e.tag) return this._handleNoDirective(e, i); const o = document.createElement(e.tag); return "form" === e.tag && o.addEventListener("submit", (function (e) { e.preventDefault() })), e.directives && e.directives["@go"] && e._goId && (o.setAttribute("data-ayisha-go-id", e._goId), o.style.cursor = "pointer"), Object.entries(e.attrs).forEach((([e, t]) => { o.setAttribute(e, this.evaluator.evalAttrValue(t, i)) })), e.subDirectives?.["@text"] && (e.children && e.children.length > 0 ? o._ayishaOriginalText = e.children.filter((e => "text" === e.type)).map((e => e.text)).join("") : o._ayishaOriginalText = o.textContent || o.innerText || ""), this._handleSpecialDirectives(o, e, i), this.directiveManager.applyDirectives(e, i, this.state, o, s), e.children.forEach((e => { const t = this._renderVNode(e, i); t && o.appendChild(t) })), s && !s.done && s.total > 0 && s.markSyncDone(), o } _handleFunctionalDirectives(e, t, i = null) { let s = this.evaluator.evalExpr(e.directives["@source"], t), r = []; r = Array.isArray(s) ? s : s && "object" == typeof s ? Object.values(s) : null == s ? [] : [s]; const n = (e, t) => { JSON.stringify(this.state[e]) !== JSON.stringify(t) && Object.defineProperty(this.state, e, { value: t, writable: !0, configurable: !0, enumerable: !0 }) }; let a = !1; if (e.directives["@map"]) { a = !0; try { const t = e.directives["@map"]; let i; if (t.includes("=>")) { const [e, s] = t.split("=>").map((e => e.trim())); i = new Function(e.trim(), `return (${s})`) } else i = new Function("item", `return (${t})`); const s = r.map(i); n(e.directives["@result"] || "result", s) } catch (t) { n(e.directives["@result"] || "result", []) } } if (e.directives["@filter"]) { a = !0; try { const t = e.directives["@filter"]; let i; if (t.includes("=>")) { const [e, s] = t.split("=>").map((e => e.trim())); i = new Function(e.trim(), `return (${s})`) } else i = new Function("item", `return (${t})`); const s = r.filter(i); n(e.directives["@result"] || "result", s) } catch (t) { n(e.directives["@result"] || "result", []) } } if (e.directives["@reduce"]) { a = !0; try { const i = e.directives["@reduce"]; let s; if (i.includes("=>")) { const [e, t] = i.split("=>").map((e => e.trim())), [r, n] = e.replace(/[()]/g, "").split(",").map((e => e.trim())); s = new Function(r, n, `return (${t})`) } else s = new Function("acc", "item", `return (${i})`); const a = e.directives["@initial"] ? this.evaluator.evalExpr(e.directives["@initial"], t) : void 0; let o; o = 0 === r.length ? void 0 !== a ? a : void 0 : void 0 !== a ? r.reduce(s, a) : r.reduce(s), n(e.directives["@result"] || "result", o) } catch (i) { const s = e.directives["@initial"] ? this.evaluator.evalExpr(e.directives["@initial"], t) : void 0; n(e.directives["@result"] || "result", void 0 !== s ? s : void 0) } } return i && i.addTask((() => Promise.resolve())), a ? document.createComment("functional") : null } _handleComponentDirective(e, t, i = null) { const s = this.directiveManager.directives.get("@component"), r = { ...this.state, _ayishaInstance: this }; return s.apply(e, t, r, null, i) } _processComponentInitBlocks(e) { const t = e.querySelectorAll("init"), i = []; t.forEach((e => { const t = e.textContent.trim(); t && (this._initBlocks.includes(t) || (i.push(t), this._initBlocks.push(t))), e.remove() })), this._runInitBlocksImmediate(i) } _runInitBlocksImmediate(e) { e.forEach((e => { if (!e || !e.trim()) return; let t = e.trim().replace(/[\u200B-\u200D\uFEFF]/g, "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/\n\s*\n/g, "\n").replace(/\n\s+/g, "\n").trim(); const i = t.split("\n"); t = i.map((e => { const t = e.trim(); if (!t || t.startsWith("//") || t.startsWith("/*") || t.startsWith("function") || t.includes("function(") || t.includes("=>") || /^(if|else|for|while|switch|case|default|try|catch|finally|return|var|let|const)\b/.test(t)) return e; const i = t.match(/^([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(.+)$/); if (i && !t.includes("state.") && !t.includes("this.") && !t.includes("window.") && !t.includes("console.") && !t.includes("localStorage.") && !t.includes("sessionStorage.")) { const [, t, s] = i; if (!["JSON", "Object", "Array", "String", "Number", "Boolean", "Date", "Math", "RegExp"].includes(t)) return e.replace(i[0], `state.${t} = ${s}`) } return e })).join("\n"); try { new Function("state", t)(this.state) } catch (e) { } })) } _handleNoDirective(e, t) { const i = document.createElement("span"); if (void 0 !== e.rawContent) i.textContent = e.rawContent; else { let t = ""; const s = e => { if ("string" == typeof e) return e; if ("text" === e.type) return e.content || ""; if (e.tag) { let t = ""; e.attrs && (t = Object.entries(e.attrs).map((([e, t]) => ` ${e}="${t}"`)).join("")); let i = ""; e.directives && (i = Object.entries(e.directives).map((([e, t]) => ` ${e}="${t}"`)).join("")); let r = ""; e.subDirectives && Object.entries(e.subDirectives).forEach((([e, t]) => { Object.entries(t).forEach((([t, i]) => { r += ` ${e}:${t}="${i}"` })) })); const n = e.children ? e.children.map(s).join("") : ""; return `<${e.tag}${t}${i}${r}>${n}</${e.tag}>` } return "" }; e.children && e.children.length > 0 && (t = e.children.map(s).join("")), i.textContent = t } return i } _handleSpecialDirectives(e, t, i) { if (t.directives && t.directives["@set"] && !t._setProcessed) { const s = t.directives["@set"], r = `${t.tag}-${JSON.stringify(t.attrs)}-${s}`; if (this._processedSetDirectives || (this._processedSetDirectives = new Set), !this._processedSetDirectives.has(r)) { this._processedSetDirectives.add(r); try { const e = /([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=([^=].*)/g; let t; for (; null !== (t = e.exec(s));) { const e = t[1]; e in this.state && void 0 !== this.state[e] || (this.state[e] = this.evaluator.evalExpr(t[2], i)) } } catch (t) { e.setAttribute("data-ayisha-set-error", t.message) } } return t._setProcessed = !0, delete t.directives["@set"], void (e.parentNode && e.parentNode.removeChild(e)) } if (t.directives.hasOwnProperty("@attr")) { const t = document.createElement("div"); t.style.backgroundColor = "rgba(0, 0, 0, 0.8)", t.style.color = "#fff", t.style.padding = "1em", t.style.borderRadius = "4px", t.style.marginTop = "1em", t.style.overflow = "auto"; const i = document.createElement("h3"); i.textContent = "STATE ATTRIBUTES", i.style.margin = "0.5em 0 2em", i.style.fontSize = "1.1em", i.style.fontWeight = "bold", i.style.color = "#fff", t.appendChild(i); const s = document.createElement("ul"); s.style.margin = "0", s.style.padding = "0 0 0 1.2em", s.style.fontFamily = "monospace", s.style.fontSize = "1em", Object.keys(this.state).forEach((e => { const t = document.createElement("li"); t.textContent = e, s.appendChild(t) })), t.appendChild(s), e.appendChild(t) } if (t.directives.hasOwnProperty("@log")) { this.centralLogger && this.centralLogger.loggers && 0 !== Object.keys(this.centralLogger.loggers).length || this.centralLogger.initializeLoggers(this.evaluator, this.fetchManager, this.componentManager); try { const s = { tagName: e.tagName, className: e.className, id: e.id }; this.centralLogger.addLog(s, t, i, this.state, e); const r = { tag: t.tag, directives: { ...t.directives }, subDirectives: { ...t.subDirectives }, elementInfo: s }; if (e.setAttribute("data-ayisha-log", "true"), e.setAttribute("data-ayisha-log-info", JSON.stringify(r)), t.directives["@click"]) { const r = this.centralLogger.loggers["@click"]; r && (this.centralLogger.clickLoggers.set(e, r), e.addEventListener("click", (() => { r.recordClick(), this.centralLogger.addLog(s, t, i, this.state, e) }))) } } catch (t) { e.setAttribute("data-ayisha-log-error", t.message) } } } mount() { if (this.root.childNodes.forEach((e => { 1 === e.nodeType && e.tagName && "init" === e.tagName.toLowerCase() && this.parser.parse(e) })), this.root.childNodes.length > 1) { const e = { tag: "fragment", attrs: {}, directives: {}, subDirectives: {}, children: [] }; this.root.childNodes.forEach((t => { if (1 === t.nodeType && t.tagName && "init" === t.tagName.toLowerCase()) return; const i = this.parse(t); i && e.children.push(i) })), this._vdom = e } else this._vdom = this.parse(this.root); if (!this.state._currentPage) { const e = this._findFirstPageDirective(this._vdom); e && (this.state._currentPage = e.directives["@page"]) } this._preInitializeEssentialVariables(), this._makeReactive(), this._runInitBlocks(), this.reactivitySystem.enableWatchers(), this._setupRouting(), this.router.setupCurrentPageProperty(), this.preloadComponents().then((() => { this._isRendering || this.render() })), this.render(), this.root.addEventListener("click", (e => { let t = e.target; for (; t && t !== this.root;) { if (t.hasAttribute("@link")) { e.preventDefault(); const i = t.getAttribute("@link"); let s = i; return i.startsWith("/") && (s = i.substring(1)), this.state._currentPage = s, void this.render() } t = t.parentNode } }), !0) } hydrate(e = null) { if ("undefined" != typeof window) { const t = e || window.__AYISHA_HYDRATION_DATA__; t && t.state && (this.state = { ...this.state, ...t.state }, this._isHydrationMode = !0) } return this._vdom = this.parse(this.root), this._preInitializeEssentialVariables(), this._makeReactive(), this._runInitBlocks(), this.reactivitySystem.enableWatchers(), this._setupRouting(), this.router.setupCurrentPageProperty(), this._hydrateEventListeners(), this._hydrateBindings(), this.preloadComponents(), this } _hydrateEventListeners() { this.root.querySelectorAll('[data-ayisha-hydrate="true"]').forEach((e => { try { const t = e.getAttribute("data-ayisha-directives"); if (t) { const i = JSON.parse(t), s = { tag: e.tagName.toLowerCase(), directives: i, subDirectives: {} }; this._hydrateInteractiveDirectives(s, this.state, e) } } catch (e) { } })) } _hydrateInteractiveDirectives(e, t, i) { ["@click", "@input", "@change", "@focus", "@blur", "@hover", "@model"].forEach((s => { if (e.directives[s]) { const r = this.directiveManager.getDirective(s); if (r) try { r.apply(e, t, this.state, i) } catch (e) { } } })) } _hydrateBindings() { this.root.querySelectorAll("input, textarea, select").forEach((e => { const t = e.getAttribute("@model") || e.getAttribute("data-model"); t && this.bindingManager.bindModel(e, t, this.state) })) } } "undefined" != typeof window && (window.AyishaVDOM = we), "undefined" != typeof module && module.exports && (module.exports = we), we.createSSRInstance = function (e = {}) { return new we({ childNodes: [], querySelectorAll: () => [], addEventListener: () => { }, innerHTML: "" }, { ...e, ssr: !0 }) }, we.hydrate = function (e = document.body, t = null) { return new we(e, { hydration: !0 }).hydrate(t) }; const xe = () => { if ("undefined" == typeof document) return; if (!document.getElementById("ayisha-default-animations")) { const e = document.createElement("style"); e.id = "ayisha-default-animations", e.textContent = "\n        /* FadeIn animation for both .fadeIn and .fade-in */\n        .fadeIn, .fade-in {\n          animation: ayishaFadeIn 0.3s ease-in-out;\n        }\n\n        @keyframes ayishaFadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n\n        /* Slide-down animation */\n        .slide-down {\n          overflow: hidden;\n          transition: height 0.3s ease-in-out;\n        }\n\n        /* Styles for @log display as sibling */\n        .ayisha-log-display {\n          background: rgba(0, 20, 40, 0.95) !important;\n          color: #fff !important;\n          padding: 8px 12px !important;\n          margin: 4px 0 !important;\n          border-radius: 6px !important;\n          font-family: 'JetBrains Mono', 'Courier New', monospace !important;\n          font-size: 11px !important;\n          border-left: 4px solid #0066cc !important;\n          box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;\n          max-width: 400px !important;\n          overflow-x: auto !important;\n          line-height: 1.4 !important;\n          display: block !important;\n        }\n\n        /* Styles for @log error display */\n        .ayisha-log-error-display {\n          background: rgba(255, 0, 0, 0.9) !important;\n          color: white !important;\n          padding: 8px 12px !important;\n          margin: 4px 0 !important;\n          border-radius: 6px !important;\n          font-family: monospace !important;\n          font-size: 11px !important;\n          font-weight: bold !important;\n          display: block !important;\n        }\n      ", document.head.appendChild(e) } }; "undefined" != typeof window && "undefined" != typeof document && ("loading" === document.readyState ? document.addEventListener("DOMContentLoaded", (() => { xe(), "undefined" != typeof window && window.__AYISHA_HYDRATION_DATA__ ? new we(document.body).hydrate() : new we(document.body).mount() })) : (xe(), "undefined" != typeof window && window.__AYISHA_HYDRATION_DATA__ ? new we(document.body).hydrate() : new we(document.body).mount())) }();